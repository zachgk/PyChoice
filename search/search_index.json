{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyChoice","text":"<p>A library for managing choices, options, and configurations across abstraction hierarchy.</p> <ul> <li>Github repository: https://github.com/zachgk/PyChoice/</li> </ul> <p>The pychoice library is a python implementation of choice as described in this blog post by Zach Kimberg (who also authored this library). The best way to think of pychoice is that it is a pseudo-new feature of the python programming language implemented as a library. It can be used for how to manage complexity around making modules heavily customizable. And this is done by customizing it through the use of choice. This includes customization across abstraction boundaries.</p>"},{"location":"#overview","title":"Overview","text":"<p>Let's say we have a simple greeting function that we will define as a choice function:</p> <pre><code>@choice.func(args=[\"greeting\"])\ndef greet(name: str, greeting=\"Hello\"):\n    return f\"{greeting} {name}\"\n</code></pre> <p>Now we might integrate this function into a larger application like an email broadcast to all subscribers. For example, we might have a call stack like <code>my_application() &gt; ... &gt; emailBroadCast() &gt; writeEmail() &gt; writeEmailBody() &gt; greet()</code> where this greeting function is buried in a lot of other functions.</p> <p>But that means if you want to customize the greeting for your email broadcast, you would have two options. Either every single function in the chain would have to pass on a override greeting which makes them unreadable. Or you would define a dict or class to store an <code>EmailConfig</code> which contains the greeting. This works better, but rarely do these configs offer enough flexibility to work for all use cases.</p> <p>With a choice function, these can be controlled by using choice rules like this:</p> <pre><code># Create a choice rule to override the behavior\nchoice.rule([my_application, greet], greet, greeting=\"Hi\")\n\n# Create another overriding rule\nchoice.rule([my_application, serious_message, greet], greet, greeting=\"Dear Sir or Madam\")\n</code></pre> <p>Like this, you can add a collection of rules to determine which greeting you use. And these rules can control functions ignoring abstraction boundaries which should not apply to choices. This includes in other functions, modules, or libraries which can now systematically offer more control by using choice functions.</p> <p>The rules help define situations where you want to use a particular choice. Some may be broad rules that affect many cases or others can be narrow and targeted to a specific usage. In the case that multiple conflicting rules affect the same situation, the most precise rule takes precedence.</p>"},{"location":"#advanced-usage","title":"Advanced Usage","text":"<p>But let's say that the arguments which you (optionally) add to your choice function don't provide enough flexibility. Maybe you need a new format for the greeting. For this, you can define a full override.</p> <p>Think of the original signature like a function interface. Then you can have multiple implementations of the interface and use choice rules to control which implementation gets used. It would look like:</p> <pre><code>@choice.impl(implements=greet, args=[\"greeting\", \"title\"])\ndef greet_with_title(name: str, greeting=\"Hello\", title=\"user\"):\n    return f\"{greeting} {name} the {title}\"\n\nchoice.rule([my_application, happy_message, greet], greet_with_title, greeting=\"Hi\", title=\"best user of my application in the whole wide world\")\n</code></pre> <p>Like this, the choice customization can behave like a systematic code injection system. Remember that it can also inject code into libraries, so it can act as a way for libraries to allow hooks or overrides.</p>"},{"location":"#status","title":"Status","text":"<p>The current status of PyChoice is a work in progress that I am publishing as a demonstration to GitHub. It is not currently being published to PyPi but open an issue if anyone finds this and is interested in it and I can begin doing so. There are also some helper features likely missing from the library such as supporting contexts with a <code>with</code> statement, using classes and inheritance, and helpers for patterns of choices like event listeners.</p> <p>Likewise, the dev tooling is a key component of working with this kind of complexity. For example, understanding which choices are made would be improved with a UI display of the logic. You can debug a function to follow choices, but it would help to have this as a tracing capability. The trace could also then be used for golden testing choices to ensure no changes are made accidentally. It would also help to have integration into documentation tools like sphinx to better expose what choice options are available.</p>"},{"location":"functions/","title":"Functions","text":"<p>This guide covers the fundamental building blocks of PyChoice: creating choice (interface) functions and implementations.</p>"},{"location":"functions/#creating-choice-functions","title":"Creating Choice Functions","text":"<p>Choice functions are the core concept in PyChoice. They allow you to define functions that can have their behavior customized through rules and overloaded with various implementations.</p>"},{"location":"functions/#basic-choice-function","title":"Basic Choice Function","text":"<p>Use the <code>@choice.func()</code> decorator to create a choice function:</p> <pre><code>import pychoice as choice\n\n@choice.func()\ndef greet(name: str):\n    return f\"Hello {name}\"\n\n# Basic usage\nprint(greet(\"World\"))  # Output: Hello World\n</code></pre>"},{"location":"functions/#choice-arguments","title":"Choice Arguments","text":"<p>Choice functions become powerful when you define choice arguments using the <code>args</code> parameter:</p> <pre><code>@choice.func(args=[\"greeting\"])\ndef greet(name: str, greeting=\"Hello\"):\n    return f\"{greeting} {name}\"\n\n# The greeting parameter can now be customized via rules\nprint(greet(\"World\"))  # Output: Hello World\n</code></pre>"},{"location":"functions/#email-system-example","title":"Email System Example","text":"<p>Let's build a practical example using an email system that needs different greeting styles:</p> <pre><code>@choice.func(args=[\"greeting\"])\ndef greet(name: str, greeting=\"Hello\"):\n    return f\"{greeting} {name}\"\n\ndef my_application():\n    return email_broadcast()\n\ndef email_broadcast():\n    return write_email()\n\ndef write_email():\n    return write_email_body()\n\ndef write_email_body():\n    # Greeting is called deep in the call stack\n    message = greet(\"John\")\n    return f\"Email body: {message}\"\n\n# Run the application\nresult = my_application()\nprint(result)  # Output: Email body: Hello John\n</code></pre>"},{"location":"functions/#choice-implementations","title":"Choice Implementations","text":"<p>You can create entirely different implementations of a choice function using <code>@choice.impl</code>:</p>"},{"location":"functions/#creating-additional-implementations","title":"Creating Additional Implementations","text":"<pre><code>@choice.impl(implements=greet)\ndef formal_greet(name: str):\n    return f\"Dear {name}\"\n\n@choice.impl(implements=greet, args=[\"greeting\", \"title\"])\ndef greet_with_title(name: str, greeting=\"Hello\", title=\"user\"):\n    return f\"{greeting} {name} the {title}\"\n</code></pre>"},{"location":"functions/#wrapping-functions","title":"Wrapping Functions","text":"<p>You can also wrap existing functions to make them choice-compatible:</p> <pre><code>def simple_greet(name: str):\n    return f\"Hi {name}\"\n\n# Wrap an existing function\nwrapped_greet = choice.wrap(simple_greet, implements=greet)\n</code></pre>"},{"location":"functions/#function-testing-and-debugging","title":"Function Testing and Debugging","text":""},{"location":"functions/#basic-testing","title":"Basic Testing","text":"<p>Test your choice functions like regular Python functions:</p> <pre><code>def test_basic_greeting():\n    assert greet(\"test\") == \"Hello test\"\n\ndef test_custom_greeting():\n    # This will use a rule (covered in Rules documentation)\n    assert greet(\"test\") == \"Hi test\"\n</code></pre>"},{"location":"functions/#tracing-function-calls","title":"Tracing Function Calls","text":"<p>PyChoice includes tracing capabilities to help understand function behavior:</p> <pre><code># Start tracing\nchoice.trace_start()\n\n# Run your functions\nresult = my_application()\n\n# Stop tracing and examine results\ntrace = choice.trace_stop()\nprint(trace)  # Shows which choice functions were called\n\n# Save trace for analysis\ntrace.save(\"function_trace.json\")\n</code></pre>"},{"location":"functions/#choice-arguments_1","title":"Choice Arguments","text":"<p>Choice function implementations (both default and additional implementations) can have choice arguments. These allow you to parameterize the implementation so there are additional dimensions they can be later customized through rules.</p> <pre><code>@choice.func(args=[\"format\", \"prefix\"])\ndef format_message(content: str, format=\"text\", prefix=\"\"):\n    \"\"\"\n    content: regular parameter (required)\n    format: choice argument with default\n    prefix: choice argument with default\n    \"\"\"\n    message = f\"{prefix}{content}\" if prefix else content\n\n    if format == \"text\":\n        return message\n    elif format == \"html\":\n        return f\"&lt;p&gt;{message}&lt;/p&gt;\"\n    elif format == \"markdown\":\n        return f\"**{message}**\"\n\n    return message\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>PyChoice is currently a work in progress and not yet published to PyPI. To install it, you'll need to clone the repository and install it locally:</p> <pre><code>git clone https://github.com/zachgk/PyChoice.git\ncd PyChoice\n\nuv pip install  # Install to pip\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Functions - creating choice functions and implementations</li> <li>Understand Rules - customizing function behavior with the rule system</li> <li>Check the API Reference for complete documentation</li> <li>Learn about tracing and visualization features</li> </ul>"},{"location":"modules/","title":"API Reference","text":""},{"location":"modules/#core-functions-module","title":"Core Functions Module","text":"<p>Core functionality for PyChoice - choice functions, decorators, and tracing.</p> <p>This module contains the primary implementation of choice functions, including decorators for creating choice functions and implementations, tracing capabilities, and the core ChoiceFunction class that handles rule matching and execution.</p>"},{"location":"modules/#pychoice.funcs.registry","title":"<code>registry = []</code>  <code>module-attribute</code>","text":"<p>Global registry of all ChoiceFunctions created with @func decorator.</p>"},{"location":"modules/#pychoice.funcs.ChoiceFunction","title":"<code>ChoiceFunction</code>","text":"<p>The core choice function that manages rules and dispatches to implementations.</p> <p>ChoiceFunction is created by the @func decorator and serves as the central orchestrator for choice-based function calls. It maintains a registry of rules and alternative implementations, selecting the most appropriate one based on the current call stack.</p> <p>Attributes:</p> Name Type Description <code>id</code> <p>Unique identifier for this choice function</p> <code>interface</code> <code>ChoiceFuncImplementation[O]</code> <p>The default ChoiceFuncImplementation</p> <code>funcs</code> <code>dict[UUID, ChoiceFuncImplementation[O]]</code> <p>Dictionary of alternative implementations by UUID</p> <code>rules</code> <code>list[Rule]</code> <p>List of rules that apply to this choice function</p> Example <pre><code>@choice.func(args=[\"greeting\"])\ndef greet(name: str, greeting=\"Hello\"):\n    return f\"{greeting} {name}\"\n# greet is now a ChoiceFunction instance\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>class ChoiceFunction[O]:\n    \"\"\"The core choice function that manages rules and dispatches to implementations.\n\n    ChoiceFunction is created by the @func decorator and serves as the central\n    orchestrator for choice-based function calls. It maintains a registry of\n    rules and alternative implementations, selecting the most appropriate one\n    based on the current call stack.\n\n    Attributes:\n        id: Unique identifier for this choice function\n        interface: The default ChoiceFuncImplementation\n        funcs: Dictionary of alternative implementations by UUID\n        rules: List of rules that apply to this choice function\n\n    Example:\n        ```python\n        @choice.func(args=[\"greeting\"])\n        def greet(name: str, greeting=\"Hello\"):\n            return f\"{greeting} {name}\"\n        # greet is now a ChoiceFunction instance\n        ```\n    \"\"\"\n    def __init__(self, interface: ChoiceFuncImplementation[O]) -&gt; None:\n        \"\"\"Initialize a ChoiceFunction with a default implementation.\n\n        Args:\n            interface: The default ChoiceFuncImplementation to use\n        \"\"\"\n        self.id = uuid5(UUID_NAMESPACE, f\"{interface.func.__module__}.{interface.func.__name__}\")\n        self.interface: ChoiceFuncImplementation[O] = interface\n        self.funcs: dict[UUID, ChoiceFuncImplementation[O]] = {}\n        self.rules: list[Rule] = []\n\n    def __str__(self) -&gt; str:\n        return f\"ChoiceFunction({self.interface.func.__name__})\"\n\n    def _add_func(self, f: Callable[..., Any], func: ChoiceFuncImplementation[O]) -&gt; None:\n        \"\"\"Add an alternative implementation to this choice function.\n\n        Args:\n            f: The original function (unused but kept for compatibility)\n            func: The ChoiceFuncImplementation to add\n        \"\"\"\n        self.funcs[func.id] = func\n\n    def _add_rule(self, rule: Rule) -&gt; None:\n        \"\"\"Add a rule to this choice function.\n\n        Args:\n            rule: The Rule to add to the rule list\n        \"\"\"\n        self.rules.append(rule)\n\n    def _sorted_selectors(self, stack_info: OptStackFrame = None) -&gt; list[MatchedRule]:\n        \"\"\"Get matching rules sorted by specificity.\n\n        Args:\n            stack_info: Optional stack frames, uses current stack if None\n\n        Returns:\n            List of MatchedRules sorted from least to most specific\n        \"\"\"\n        if not self.rules:\n            return []\n        if stack_info is None:\n            stack_info = inspect.stack()\n\n        # Get indices and filter to only matching\n        rules = []\n        for r in self.rules:\n            matched_rule = r.selector.matches(stack_info, r)\n            if matched_rule is not None:\n                rules.append(matched_rule)\n        if not rules:\n            return []\n\n        def compare(a: MatchedRule, b: MatchedRule) -&gt; int:\n            return a.rule.selector.compare(b.rule.selector, stack_info)\n\n        # Sort\n        rules = sorted(rules, key=cmp_to_key(compare))\n\n        return rules\n\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; O:\n        stack_info = inspect.stack()\n        rules = self._sorted_selectors(stack_info)\n\n        impl = self.interface\n        for rule in reversed(rules):\n            if rule.impl is not None:\n                impl = rule.impl  # Override with best matched rule if one is applicable\n                break\n\n        # Prune non-matching implementations for arg overrides\n        rules = [r for r in rules if r.rule.impl == impl or r.rule.impl is None]\n\n        if isinstance(impl, ChoiceFuncImplementation):\n            pass\n        elif isinstance(impl, ChoiceFunction):\n            impl = impl.interface\n        else:\n            raise NonRule()\n\n        choice_kwargs = impl.choice_kwargs(rules, args, kwargs)\n        trace_status.call_begin(TraceItem(self, impl, rules, stack_info, args, kwargs, choice_kwargs))\n        res = impl.func(*args, **choice_kwargs)\n        trace_status.call_end()\n        return res\n</code></pre>"},{"location":"modules/#pychoice.funcs.ChoiceFunction.__init__","title":"<code>__init__(interface)</code>","text":"<p>Initialize a ChoiceFunction with a default implementation.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>ChoiceFuncImplementation[O]</code> <p>The default ChoiceFuncImplementation to use</p> required Source code in <code>pychoice/funcs.py</code> <pre><code>def __init__(self, interface: ChoiceFuncImplementation[O]) -&gt; None:\n    \"\"\"Initialize a ChoiceFunction with a default implementation.\n\n    Args:\n        interface: The default ChoiceFuncImplementation to use\n    \"\"\"\n    self.id = uuid5(UUID_NAMESPACE, f\"{interface.func.__module__}.{interface.func.__name__}\")\n    self.interface: ChoiceFuncImplementation[O] = interface\n    self.funcs: dict[UUID, ChoiceFuncImplementation[O]] = {}\n    self.rules: list[Rule] = []\n</code></pre>"},{"location":"modules/#pychoice.funcs.ChoiceJSONEncoder","title":"<code>ChoiceJSONEncoder</code>","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>Custom JSON encoder for PyChoice objects.</p> <p>This encoder handles serialization of PyChoice-specific objects like TraceItems, Traces, ChoiceFunctions, and Rules into JSON format. It's used primarily for trace serialization and debugging.</p> Example <pre><code>trace_data = json.dumps(trace, cls=ChoiceJSONEncoder, indent=2)\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>class ChoiceJSONEncoder(json.JSONEncoder):\n    \"\"\"Custom JSON encoder for PyChoice objects.\n\n    This encoder handles serialization of PyChoice-specific objects like\n    TraceItems, Traces, ChoiceFunctions, and Rules into JSON format.\n    It's used primarily for trace serialization and debugging.\n\n    Example:\n        ```python\n        trace_data = json.dumps(trace, cls=ChoiceJSONEncoder, indent=2)\n        ```\n    \"\"\"\n    def default(self, obj: Any) -&gt; Any:\n        \"\"\"Convert PyChoice objects to JSON-serializable dictionaries.\n\n        Args:\n            obj: Object to serialize\n\n        Returns:\n            JSON-serializable representation of the object\n        \"\"\"\n        if isinstance(obj, TraceItem):\n            return obj.to_dict()\n        elif isinstance(obj, Trace):\n            return {\"items\": [item.to_dict() for item in obj.items], \"registry\": {str(f.id): f for f in registry}}\n        elif isinstance(obj, ChoiceFunction):\n            return {\n                \"id\": str(obj.id),\n                \"interface\": obj.interface,\n                \"funcs\": {str(k): v for k, v in obj.funcs.items()},\n                \"rules\": obj.rules,\n            }\n        elif isinstance(obj, ChoiceFuncImplementation):\n            return {\n                \"id\": str(obj.id),\n                \"func\": getattr(obj.func, \"__name__\", str(obj)),\n                \"module\": getattr(obj.func, \"__module__\", \"\"),\n                \"defaults\": {k: str(v) for k, v in obj.defaults.items()},\n                \"doc\": inspect.getdoc(obj.func),\n            }\n        elif isinstance(obj, Rule):\n            return {\n                \"selector\": str(obj.selector),\n                \"impl\": str(obj.impl.id if obj.impl is not None else None),\n                \"doc\": obj.doc,\n            }\n        elif isinstance(obj, MatchedRule):\n            return {\n                \"rule\": obj.rule,\n                \"captures\": obj.captures,\n                \"vals\": {k: str(v) for k, v in obj.vals.items()},\n            }\n        try:\n            return super().default(obj)\n        except Exception:\n            return type(obj).__name__\n</code></pre>"},{"location":"modules/#pychoice.funcs.ChoiceJSONEncoder.default","title":"<code>default(obj)</code>","text":"<p>Convert PyChoice objects to JSON-serializable dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Object to serialize</p> required <p>Returns:</p> Type Description <code>Any</code> <p>JSON-serializable representation of the object</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def default(self, obj: Any) -&gt; Any:\n    \"\"\"Convert PyChoice objects to JSON-serializable dictionaries.\n\n    Args:\n        obj: Object to serialize\n\n    Returns:\n        JSON-serializable representation of the object\n    \"\"\"\n    if isinstance(obj, TraceItem):\n        return obj.to_dict()\n    elif isinstance(obj, Trace):\n        return {\"items\": [item.to_dict() for item in obj.items], \"registry\": {str(f.id): f for f in registry}}\n    elif isinstance(obj, ChoiceFunction):\n        return {\n            \"id\": str(obj.id),\n            \"interface\": obj.interface,\n            \"funcs\": {str(k): v for k, v in obj.funcs.items()},\n            \"rules\": obj.rules,\n        }\n    elif isinstance(obj, ChoiceFuncImplementation):\n        return {\n            \"id\": str(obj.id),\n            \"func\": getattr(obj.func, \"__name__\", str(obj)),\n            \"module\": getattr(obj.func, \"__module__\", \"\"),\n            \"defaults\": {k: str(v) for k, v in obj.defaults.items()},\n            \"doc\": inspect.getdoc(obj.func),\n        }\n    elif isinstance(obj, Rule):\n        return {\n            \"selector\": str(obj.selector),\n            \"impl\": str(obj.impl.id if obj.impl is not None else None),\n            \"doc\": obj.doc,\n        }\n    elif isinstance(obj, MatchedRule):\n        return {\n            \"rule\": obj.rule,\n            \"captures\": obj.captures,\n            \"vals\": {k: str(v) for k, v in obj.vals.items()},\n        }\n    try:\n        return super().default(obj)\n    except Exception:\n        return type(obj).__name__\n</code></pre>"},{"location":"modules/#pychoice.funcs.Match","title":"<code>Match</code>","text":"<p>               Bases: <code>SelectorItem</code></p> <p>Advanced selector item that matches function calls with specific argument values.</p> <p>Match extends basic function matching to also check argument values, allowing for more precise rule targeting based on function parameters.</p> <p>Attributes:</p> Name Type Description <code>item</code> <p>The underlying SelectorItem to match</p> <code>match_kwargs</code> <p>Keyword arguments that must match for this selector to apply</p> Example <pre><code># Match greet() calls where greeting=\"Hi\"\nmatch_item = Match(greet, greeting=\"Hi\")\nselector = Selector([my_app, match_item])\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>class Match(SelectorItem):\n    \"\"\"Advanced selector item that matches function calls with specific argument values.\n\n    Match extends basic function matching to also check argument values, allowing\n    for more precise rule targeting based on function parameters.\n\n    Attributes:\n        item: The underlying SelectorItem to match\n        match_kwargs: Keyword arguments that must match for this selector to apply\n\n    Example:\n        ```python\n        # Match greet() calls where greeting=\"Hi\"\n        match_item = Match(greet, greeting=\"Hi\")\n        selector = Selector([my_app, match_item])\n        ```\n    \"\"\"\n    def __init__(self, func: SEL_I, **kwargs: Any):\n        self.item = new_selector_item(func)\n        self.match_kwargs = kwargs\n\n    def __str__(self) -&gt; str:\n        return str(self.item)\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, Match) and self.item == other.item and self.match_kwargs == other.match_kwargs\n\n    def get_callable(self) -&gt; Callable[..., Any] | None:\n        \"\"\"Get the underlying callable from the wrapped selector item.\"\"\"\n        return self.item.get_callable()\n\n    def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n        \"\"\"Check if this Match selector matches a stack frame.\n\n        First checks if the underlying item matches, then verifies that\n        all specified keyword arguments match the actual call arguments.\n\n        Args:\n            frame_info: Stack frame to check for matching\n\n        Returns:\n            True if both function and arguments match, False otherwise\n        \"\"\"\n        # First check if the underlying item matches\n        if not self.item.matches(frame_info):\n            return False\n\n        # If no kwargs to match, then it's a match\n        if not self.match_kwargs:\n            return True\n\n        # Capture the arguments and compare against expected kwargs\n        captured = self.capture(frame_info)\n\n        # Check if all expected kwargs match the captured values\n        for key, expected_value in self.match_kwargs.items():\n            if key not in captured or captured[key] != expected_value:\n                return False\n\n        return True\n\n    def capture(self, frame_info: inspect.FrameInfo) -&gt; dict[str, Any]:\n        \"\"\"Capture local variables from the matching stack frame.\n\n        Args:\n            frame_info: Stack frame to capture variables from\n\n        Returns:\n            Dictionary of captured local variables\n        \"\"\"\n        return Selector._collect_captures(self.item, frame_info)\n</code></pre>"},{"location":"modules/#pychoice.funcs.Match.capture","title":"<code>capture(frame_info)</code>","text":"<p>Capture local variables from the matching stack frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame_info</code> <code>FrameInfo</code> <p>Stack frame to capture variables from</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of captured local variables</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def capture(self, frame_info: inspect.FrameInfo) -&gt; dict[str, Any]:\n    \"\"\"Capture local variables from the matching stack frame.\n\n    Args:\n        frame_info: Stack frame to capture variables from\n\n    Returns:\n        Dictionary of captured local variables\n    \"\"\"\n    return Selector._collect_captures(self.item, frame_info)\n</code></pre>"},{"location":"modules/#pychoice.funcs.Match.get_callable","title":"<code>get_callable()</code>","text":"<p>Get the underlying callable from the wrapped selector item.</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def get_callable(self) -&gt; Callable[..., Any] | None:\n    \"\"\"Get the underlying callable from the wrapped selector item.\"\"\"\n    return self.item.get_callable()\n</code></pre>"},{"location":"modules/#pychoice.funcs.Match.matches","title":"<code>matches(frame_info)</code>","text":"<p>Check if this Match selector matches a stack frame.</p> <p>First checks if the underlying item matches, then verifies that all specified keyword arguments match the actual call arguments.</p> <p>Parameters:</p> Name Type Description Default <code>frame_info</code> <code>FrameInfo</code> <p>Stack frame to check for matching</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if both function and arguments match, False otherwise</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n    \"\"\"Check if this Match selector matches a stack frame.\n\n    First checks if the underlying item matches, then verifies that\n    all specified keyword arguments match the actual call arguments.\n\n    Args:\n        frame_info: Stack frame to check for matching\n\n    Returns:\n        True if both function and arguments match, False otherwise\n    \"\"\"\n    # First check if the underlying item matches\n    if not self.item.matches(frame_info):\n        return False\n\n    # If no kwargs to match, then it's a match\n    if not self.match_kwargs:\n        return True\n\n    # Capture the arguments and compare against expected kwargs\n    captured = self.capture(frame_info)\n\n    # Check if all expected kwargs match the captured values\n    for key, expected_value in self.match_kwargs.items():\n        if key not in captured or captured[key] != expected_value:\n            return False\n\n    return True\n</code></pre>"},{"location":"modules/#pychoice.funcs.MismatchedTrace","title":"<code>MismatchedTrace</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Exception raised when trace begin/end calls are mismatched.</p> <p>This occurs when trace_end() is called without a corresponding trace_begin(), indicating a bug in the tracing logic.</p> Source code in <code>pychoice/funcs.py</code> <pre><code>class MismatchedTrace(RuntimeError):\n    \"\"\"Exception raised when trace begin/end calls are mismatched.\n\n    This occurs when trace_end() is called without a corresponding\n    trace_begin(), indicating a bug in the tracing logic.\n    \"\"\"\n    def __init__(self) -&gt; None:\n        super().__init__(\"Mismatched choice Trace end call\")\n</code></pre>"},{"location":"modules/#pychoice.funcs.NonRule","title":"<code>NonRule</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when an invalid rule implementation is provided.</p> <p>This occurs when trying to create a rule with something that is not a ChoiceFunction or ChoiceFuncImplementation.</p> Source code in <code>pychoice/funcs.py</code> <pre><code>class NonRule(Exception):\n    \"\"\"Exception raised when an invalid rule implementation is provided.\n\n    This occurs when trying to create a rule with something that is not\n    a ChoiceFunction or ChoiceFuncImplementation.\n    \"\"\"\n    def __init__(self) -&gt; None:\n        super().__init__(\"Expected a choice function for the rule impl\")\n</code></pre>"},{"location":"modules/#pychoice.funcs.Trace","title":"<code>Trace</code>","text":"<p>Contains the complete trace of choice function calls.</p> <p>A Trace represents the final result of tracing, containing all choice function invocations that occurred during the traced period.</p> <p>Attributes:</p> Name Type Description <code>items</code> <p>List of top-level TraceItems representing the call hierarchy</p> Example <pre><code>trace_start()\nmy_application()  # Contains choice function calls\ntrace = trace_stop()\nprint(trace)  # Shows all choice decisions made\ntrace.save(\"choices.json\")  # Save for analysis\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>class Trace:\n    \"\"\"Contains the complete trace of choice function calls.\n\n    A Trace represents the final result of tracing, containing all\n    choice function invocations that occurred during the traced period.\n\n    Attributes:\n        items: List of top-level TraceItems representing the call hierarchy\n\n    Example:\n        ```python\n        trace_start()\n        my_application()  # Contains choice function calls\n        trace = trace_stop()\n        print(trace)  # Shows all choice decisions made\n        trace.save(\"choices.json\")  # Save for analysis\n        ```\n    \"\"\"\n    def __init__(self, tracing: Tracing) -&gt; None:\n        self.items = tracing.items\n\n    def __str__(self) -&gt; str:\n        sb = io.StringIO()\n        for item in self.items:\n            item.print_item(sb, 0)\n\n        return sb.getvalue()\n\n    def save(self, filename: str) -&gt; None:\n        \"\"\"Save trace to JSON file for analysis.\n\n        Args:\n            filename: Path to save the JSON trace file\n\n        Example:\n            ```python\n            trace.save(\"debug_choices.json\")\n            ```\n        \"\"\"\n        with open(filename, \"w\") as f:\n            json.dump(self, f, cls=ChoiceJSONEncoder, indent=2)\n</code></pre>"},{"location":"modules/#pychoice.funcs.Trace.save","title":"<code>save(filename)</code>","text":"<p>Save trace to JSON file for analysis.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to save the JSON trace file</p> required Example <pre><code>trace.save(\"debug_choices.json\")\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def save(self, filename: str) -&gt; None:\n    \"\"\"Save trace to JSON file for analysis.\n\n    Args:\n        filename: Path to save the JSON trace file\n\n    Example:\n        ```python\n        trace.save(\"debug_choices.json\")\n        ```\n    \"\"\"\n    with open(filename, \"w\") as f:\n        json.dump(self, f, cls=ChoiceJSONEncoder, indent=2)\n</code></pre>"},{"location":"modules/#pychoice.funcs.TraceItem","title":"<code>TraceItem</code>","text":"<p>Represents a single choice function call in a trace.</p> <p>TraceItems capture the complete context of a choice function invocation, including which implementation was used, what rules applied, and the arguments involved. They form a hierarchical structure to represent nested choice function calls.</p> <p>Attributes:</p> Name Type Description <code>func</code> <p>The ChoiceFunction that was called</p> <code>impl</code> <p>The ChoiceFuncImplementation that was executed</p> <code>rules</code> <p>List of MatchedRules that applied to this call</p> <code>stack_info</code> <p>Call stack information at time of invocation</p> <code>args</code> <p>Positional arguments passed to the function</p> <code>kwargs</code> <p>Keyword arguments passed to the function</p> <code>choice_kwargs</code> <p>Final keyword arguments after rule application</p> <code>items</code> <code>list[TraceItem]</code> <p>List of nested TraceItems for sub-calls</p> Source code in <code>pychoice/funcs.py</code> <pre><code>class TraceItem:\n    \"\"\"Represents a single choice function call in a trace.\n\n    TraceItems capture the complete context of a choice function invocation,\n    including which implementation was used, what rules applied, and the\n    arguments involved. They form a hierarchical structure to represent\n    nested choice function calls.\n\n    Attributes:\n        func: The ChoiceFunction that was called\n        impl: The ChoiceFuncImplementation that was executed\n        rules: List of MatchedRules that applied to this call\n        stack_info: Call stack information at time of invocation\n        args: Positional arguments passed to the function\n        kwargs: Keyword arguments passed to the function\n        choice_kwargs: Final keyword arguments after rule application\n        items: List of nested TraceItems for sub-calls\n    \"\"\"\n    def __init__(\n        self,\n        func: ChoiceFunction,\n        impl: ChoiceFuncImplementation,\n        rules: list[MatchedRule],\n        stack_info: list[inspect.FrameInfo],\n        args: tuple[Any, ...],\n        kwargs: dict[str, Any],\n        choice_kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Initialize a TraceItem with complete call context.\n\n        Args:\n            func: The ChoiceFunction that was invoked\n            impl: The implementation that was selected and executed\n            rules: List of rules that matched and applied\n            stack_info: Call stack frames at time of invocation\n            args: Positional arguments to the function\n            kwargs: Original keyword arguments \n            choice_kwargs: Final keyword arguments after rule processing\n        \"\"\"\n        self.func = func\n        self.impl = impl\n        self.rules = rules\n        self.stack_info = stack_info\n        self.args = args\n        self.kwargs = kwargs\n        self.choice_kwargs = choice_kwargs\n        self.items: list[TraceItem] = []\n\n    def print_item(self, sb: io.TextIOBase, indent: int = 0) -&gt; None:\n        \"\"\"Print formatted representation of this trace item.\n\n        Args:\n            sb: Text buffer to write output to\n            indent: Indentation level for nested display\n        \"\"\"\n        prefix = \" \" * indent\n        rule_str = \" -&gt; \".join(str(r) for r in self.rules) or \"No rules\"\n        sb.write(f\"{prefix}{self.func.interface.func.__name__} [{self.impl.func.__name__}]\")\n        sb.write(f\"{prefix}  Args: {self.args}, Kwargs: {self.kwargs}, Choice Kwargs: {self.choice_kwargs}\")\n        sb.write(f\"{prefix}  Rules: {rule_str}\")\n        for sub_item in self.items:\n            sub_item.print_item(sb, indent + 2)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert trace item to dictionary representation.\n\n        Returns:\n            Dictionary representation suitable for JSON serialization\n        \"\"\"\n        return {\n            \"func\": str(self.func.id),\n            \"impl\": str(self.impl.id),\n            \"rules\": self.rules,\n            \"stack_info\": [f\"{fi.function} at {fi.filename}:{fi.lineno}\" for fi in self.stack_info],\n            \"args\": [str(a) for a in self.args],\n            \"kwargs\": {k: str(v) for k, v in self.kwargs.items()},\n            \"choice_kwargs\": {k: str(v) for k, v in self.choice_kwargs.items()},\n            \"items\": [item.to_dict() for item in self.items],\n        }\n</code></pre>"},{"location":"modules/#pychoice.funcs.TraceItem.__init__","title":"<code>__init__(func, impl, rules, stack_info, args, kwargs, choice_kwargs)</code>","text":"<p>Initialize a TraceItem with complete call context.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>ChoiceFunction</code> <p>The ChoiceFunction that was invoked</p> required <code>impl</code> <code>ChoiceFuncImplementation</code> <p>The implementation that was selected and executed</p> required <code>rules</code> <code>list[MatchedRule]</code> <p>List of rules that matched and applied</p> required <code>stack_info</code> <code>list[FrameInfo]</code> <p>Call stack frames at time of invocation</p> required <code>args</code> <code>tuple[Any, ...]</code> <p>Positional arguments to the function</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>Original keyword arguments </p> required <code>choice_kwargs</code> <code>dict[str, Any]</code> <p>Final keyword arguments after rule processing</p> required Source code in <code>pychoice/funcs.py</code> <pre><code>def __init__(\n    self,\n    func: ChoiceFunction,\n    impl: ChoiceFuncImplementation,\n    rules: list[MatchedRule],\n    stack_info: list[inspect.FrameInfo],\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n    choice_kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Initialize a TraceItem with complete call context.\n\n    Args:\n        func: The ChoiceFunction that was invoked\n        impl: The implementation that was selected and executed\n        rules: List of rules that matched and applied\n        stack_info: Call stack frames at time of invocation\n        args: Positional arguments to the function\n        kwargs: Original keyword arguments \n        choice_kwargs: Final keyword arguments after rule processing\n    \"\"\"\n    self.func = func\n    self.impl = impl\n    self.rules = rules\n    self.stack_info = stack_info\n    self.args = args\n    self.kwargs = kwargs\n    self.choice_kwargs = choice_kwargs\n    self.items: list[TraceItem] = []\n</code></pre>"},{"location":"modules/#pychoice.funcs.TraceItem.print_item","title":"<code>print_item(sb, indent=0)</code>","text":"<p>Print formatted representation of this trace item.</p> <p>Parameters:</p> Name Type Description Default <code>sb</code> <code>TextIOBase</code> <p>Text buffer to write output to</p> required <code>indent</code> <code>int</code> <p>Indentation level for nested display</p> <code>0</code> Source code in <code>pychoice/funcs.py</code> <pre><code>def print_item(self, sb: io.TextIOBase, indent: int = 0) -&gt; None:\n    \"\"\"Print formatted representation of this trace item.\n\n    Args:\n        sb: Text buffer to write output to\n        indent: Indentation level for nested display\n    \"\"\"\n    prefix = \" \" * indent\n    rule_str = \" -&gt; \".join(str(r) for r in self.rules) or \"No rules\"\n    sb.write(f\"{prefix}{self.func.interface.func.__name__} [{self.impl.func.__name__}]\")\n    sb.write(f\"{prefix}  Args: {self.args}, Kwargs: {self.kwargs}, Choice Kwargs: {self.choice_kwargs}\")\n    sb.write(f\"{prefix}  Rules: {rule_str}\")\n    for sub_item in self.items:\n        sub_item.print_item(sb, indent + 2)\n</code></pre>"},{"location":"modules/#pychoice.funcs.TraceItem.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert trace item to dictionary representation.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation suitable for JSON serialization</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert trace item to dictionary representation.\n\n    Returns:\n        Dictionary representation suitable for JSON serialization\n    \"\"\"\n    return {\n        \"func\": str(self.func.id),\n        \"impl\": str(self.impl.id),\n        \"rules\": self.rules,\n        \"stack_info\": [f\"{fi.function} at {fi.filename}:{fi.lineno}\" for fi in self.stack_info],\n        \"args\": [str(a) for a in self.args],\n        \"kwargs\": {k: str(v) for k, v in self.kwargs.items()},\n        \"choice_kwargs\": {k: str(v) for k, v in self.choice_kwargs.items()},\n        \"items\": [item.to_dict() for item in self.items],\n    }\n</code></pre>"},{"location":"modules/#pychoice.funcs.TraceStatus","title":"<code>TraceStatus</code>","text":"<p>Global tracing state manager.</p> <p>TraceStatus maintains the global state of tracing, allowing trace collection to be started and stopped. It's used internally by the trace_start() and trace_stop() functions.</p> <p>Attributes:</p> Name Type Description <code>trace</code> <code>Tracing | None</code> <p>Current active Tracing instance, or None if not tracing</p> Source code in <code>pychoice/funcs.py</code> <pre><code>class TraceStatus:\n    \"\"\"Global tracing state manager.\n\n    TraceStatus maintains the global state of tracing, allowing\n    trace collection to be started and stopped. It's used internally\n    by the trace_start() and trace_stop() functions.\n\n    Attributes:\n        trace: Current active Tracing instance, or None if not tracing\n    \"\"\"\n    def __init__(self) -&gt; None:\n        self.trace: Tracing | None = None\n\n    def call_begin(self, item: TraceItem) -&gt; None:\n        \"\"\"Record the beginning of a choice function call.\n\n        Args:\n            item: TraceItem representing the call being started\n        \"\"\"\n        if self.trace is not None:\n            self.trace.begin(item)\n\n    def call_end(self) -&gt; None:\n        \"\"\"Record the end of a choice function call.\"\"\"\n        if self.trace is not None:\n            self.trace.end()\n\n    def start(self) -&gt; None:\n        \"\"\"Start a new tracing session.\"\"\"\n        self.trace = Tracing()\n\n    def stop(self) -&gt; Trace:\n        \"\"\"Stop tracing and return collected trace.\n\n        Returns:\n            Trace object containing all collected choice function calls\n        \"\"\"\n        trace = self.trace if self.trace is not None else Tracing()\n        self.trace = None\n        return Trace(trace)\n</code></pre>"},{"location":"modules/#pychoice.funcs.TraceStatus.call_begin","title":"<code>call_begin(item)</code>","text":"<p>Record the beginning of a choice function call.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>TraceItem</code> <p>TraceItem representing the call being started</p> required Source code in <code>pychoice/funcs.py</code> <pre><code>def call_begin(self, item: TraceItem) -&gt; None:\n    \"\"\"Record the beginning of a choice function call.\n\n    Args:\n        item: TraceItem representing the call being started\n    \"\"\"\n    if self.trace is not None:\n        self.trace.begin(item)\n</code></pre>"},{"location":"modules/#pychoice.funcs.TraceStatus.call_end","title":"<code>call_end()</code>","text":"<p>Record the end of a choice function call.</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def call_end(self) -&gt; None:\n    \"\"\"Record the end of a choice function call.\"\"\"\n    if self.trace is not None:\n        self.trace.end()\n</code></pre>"},{"location":"modules/#pychoice.funcs.TraceStatus.start","title":"<code>start()</code>","text":"<p>Start a new tracing session.</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start a new tracing session.\"\"\"\n    self.trace = Tracing()\n</code></pre>"},{"location":"modules/#pychoice.funcs.TraceStatus.stop","title":"<code>stop()</code>","text":"<p>Stop tracing and return collected trace.</p> <p>Returns:</p> Type Description <code>Trace</code> <p>Trace object containing all collected choice function calls</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def stop(self) -&gt; Trace:\n    \"\"\"Stop tracing and return collected trace.\n\n    Returns:\n        Trace object containing all collected choice function calls\n    \"\"\"\n    trace = self.trace if self.trace is not None else Tracing()\n    self.trace = None\n    return Trace(trace)\n</code></pre>"},{"location":"modules/#pychoice.funcs.Tracing","title":"<code>Tracing</code>","text":"<p>Manages the collection of trace items during tracing.</p> <p>Tracing maintains the active stack of TraceItems as choice functions are called, building a hierarchical structure of invocations.</p> <p>Attributes:</p> Name Type Description <code>items</code> <code>list[TraceItem]</code> <p>Completed top-level trace items</p> <code>stack</code> <code>list[TraceItem]</code> <p>Current stack of active trace items</p> Source code in <code>pychoice/funcs.py</code> <pre><code>class Tracing:\n    \"\"\"Manages the collection of trace items during tracing.\n\n    Tracing maintains the active stack of TraceItems as choice functions\n    are called, building a hierarchical structure of invocations.\n\n    Attributes:\n        items: Completed top-level trace items\n        stack: Current stack of active trace items\n    \"\"\"\n    def __init__(self) -&gt; None:\n        self.items: list[TraceItem] = []\n        self.stack: list[TraceItem] = []\n\n    def begin(self, item: TraceItem) -&gt; None:\n        \"\"\"Begin tracing a new choice function call.\n\n        Args:\n            item: TraceItem for the function call being started\n        \"\"\"\n        self.stack.append(item)\n\n    def end(self) -&gt; None:\n        \"\"\"End tracing the most recent choice function call.\n\n        Raises:\n            MismatchedTrace: If there are no active calls to end\n        \"\"\"\n        if not self.stack:\n            raise MismatchedTrace()\n        elif len(self.stack) == 1:\n            self.items.append(self.stack.pop())\n        else:\n            ended = self.stack.pop()\n            self.stack[-1].items.append(ended)\n</code></pre>"},{"location":"modules/#pychoice.funcs.Tracing.begin","title":"<code>begin(item)</code>","text":"<p>Begin tracing a new choice function call.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>TraceItem</code> <p>TraceItem for the function call being started</p> required Source code in <code>pychoice/funcs.py</code> <pre><code>def begin(self, item: TraceItem) -&gt; None:\n    \"\"\"Begin tracing a new choice function call.\n\n    Args:\n        item: TraceItem for the function call being started\n    \"\"\"\n    self.stack.append(item)\n</code></pre>"},{"location":"modules/#pychoice.funcs.Tracing.end","title":"<code>end()</code>","text":"<p>End tracing the most recent choice function call.</p> <p>Raises:</p> Type Description <code>MismatchedTrace</code> <p>If there are no active calls to end</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def end(self) -&gt; None:\n    \"\"\"End tracing the most recent choice function call.\n\n    Raises:\n        MismatchedTrace: If there are no active calls to end\n    \"\"\"\n    if not self.stack:\n        raise MismatchedTrace()\n    elif len(self.stack) == 1:\n        self.items.append(self.stack.pop())\n    else:\n        ended = self.stack.pop()\n        self.stack[-1].items.append(ended)\n</code></pre>"},{"location":"modules/#pychoice.funcs.def_rule","title":"<code>def_rule(selector)</code>","text":"<p>Decorator for creating dynamic rules with custom logic.</p> <p>Unlike simple rules created with rule(), def_rule allows you to create rules with custom logic that can dynamically determine parameter values based on captured variables from the call stack.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>SEL</code> <p>List defining the call stack pattern to match</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Decorator function for the rule implementation</p> Example <pre><code>@choice.def_rule([debug_mode, log])\ndef debug_log_rule(captures):\n    # Custom logic based on captured variables\n    return None, {\"level\": \"DEBUG\", \"verbose\": True}\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def def_rule(selector: SEL) -&gt; Any:\n    \"\"\"Decorator for creating dynamic rules with custom logic.\n\n    Unlike simple rules created with rule(), def_rule allows you to create\n    rules with custom logic that can dynamically determine parameter values\n    based on captured variables from the call stack.\n\n    Args:\n        selector: List defining the call stack pattern to match\n\n    Returns:\n        Decorator function for the rule implementation\n\n    Example:\n        ```python\n        @choice.def_rule([debug_mode, log])\n        def debug_log_rule(captures):\n            # Custom logic based on captured variables\n            return None, {\"level\": \"DEBUG\", \"verbose\": True}\n        ```\n    \"\"\"\n    def decorator_args(func: RuleVals) -&gt; RuleVals:\n        # Choose function implementation\n        sel = new_selector(selector)\n        choice_fun = sel.choice_function()\n        if isinstance(choice_fun, ChoiceFunction):\n            choice_fun = cast(ChoiceFunction, choice_fun)\n        else:\n            raise TypeError()\n        choice_fun._add_rule(Rule(sel, None, func, inspect.getdoc(func)))\n        return func\n\n    return decorator_args\n</code></pre>"},{"location":"modules/#pychoice.funcs.func","title":"<code>func(args=None)</code>","text":"<p>Decorator to create a choice function from a regular function.</p> <p>This is the primary decorator for creating choice functions. It converts a regular function into a ChoiceFunction that can be customized through rules.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>List of parameter names that can be customized by rules</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., O]], ChoiceFunction[O]]</code> <p>Decorator function that converts a function to a ChoiceFunction</p> Example <pre><code>@choice.func(args=[\"greeting\", \"punctuation\"])\ndef greet(name: str, greeting=\"Hello\", punctuation=\"!\"):\n    return f\"{greeting} {name}{punctuation}\"\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def func[O](args: list[str] | None = None) -&gt; Callable[[Callable[..., O]], ChoiceFunction[O]]:\n    \"\"\"Decorator to create a choice function from a regular function.\n\n    This is the primary decorator for creating choice functions. It converts\n    a regular function into a ChoiceFunction that can be customized through rules.\n\n    Args:\n        args: List of parameter names that can be customized by rules\n\n    Returns:\n        Decorator function that converts a function to a ChoiceFunction\n\n    Example:\n        ```python\n        @choice.func(args=[\"greeting\", \"punctuation\"])\n        def greet(name: str, greeting=\"Hello\", punctuation=\"!\"):\n            return f\"{greeting} {name}{punctuation}\"\n        ```\n    \"\"\"\n    if args is None:\n        args = []\n\n    def decorator_args(func: F) -&gt; ChoiceFunction[O]:\n        func_args = ChoiceFuncImplementation[O](args, func)\n        # Choice interface\n\n        # Add to registry\n        reg = ChoiceFunction[O](func_args)\n        registry.append(reg)\n\n        # Return wrapper\n        return cast(ChoiceFunction[O], functools.wraps(func)(reg))\n\n    return decorator_args\n</code></pre>"},{"location":"modules/#pychoice.funcs.impl","title":"<code>impl(implements, args=None)</code>","text":"<p>Decorator to create alternative implementations for choice functions.</p> <p>This decorator creates alternative implementations that can be used by rules to completely replace the behavior of a choice function in specific contexts.</p> <p>Parameters:</p> Name Type Description Default <code>implements</code> <code>ChoiceFunction[O]</code> <p>The ChoiceFunction this will be an implementation for</p> required <code>args</code> <code>list[str] | None</code> <p>List of parameter names this implementation accepts</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., O]], ChoiceFuncImplementation[O]]</code> <p>Decorator function that creates a ChoiceFuncImplementation</p> Example <pre><code>@choice.impl(implements=greet, args=[\"greeting\", \"title\"])\ndef formal_greet(name: str, greeting=\"Dear\", title=\"\"):\n    return f\"{greeting} {title} {name}\"\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def impl[O](\n    implements: ChoiceFunction[O], args: list[str] | None = None\n) -&gt; Callable[[Callable[..., O]], ChoiceFuncImplementation[O]]:\n    \"\"\"Decorator to create alternative implementations for choice functions.\n\n    This decorator creates alternative implementations that can be used by\n    rules to completely replace the behavior of a choice function in specific contexts.\n\n    Args:\n        implements: The ChoiceFunction this will be an implementation for\n        args: List of parameter names this implementation accepts\n\n    Returns:\n        Decorator function that creates a ChoiceFuncImplementation\n\n    Example:\n        ```python\n        @choice.impl(implements=greet, args=[\"greeting\", \"title\"])\n        def formal_greet(name: str, greeting=\"Dear\", title=\"\"):\n            return f\"{greeting} {title} {name}\"\n        ```\n    \"\"\"\n    if args is None:\n        args = []\n\n    def decorator_args(func: F) -&gt; ChoiceFuncImplementation[O]:\n        func_args = ChoiceFuncImplementation[O](args, func)\n        # Choice implementation\n\n        # Add to registry\n        implements._add_func(func, func_args)\n        return cast(ChoiceFuncImplementation[O], functools.wraps(func)(func_args))\n\n    return decorator_args\n</code></pre>"},{"location":"modules/#pychoice.funcs.new_selector","title":"<code>new_selector(items, impl='')</code>","text":"<p>Create a Selector from a list of selector inputs.</p> <p>Convenience function that converts a list of various selector inputs into SelectorItems and creates a Selector.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>SEL</code> <p>List of selector inputs (functions, classes, etc.)</p> required <code>impl</code> <code>str</code> <p>Optional implementation identifier string</p> <code>''</code> <p>Returns:</p> Type Description <code>Selector</code> <p>Selector instance with converted SelectorItems</p> Example <pre><code># Create selector for my_app -&gt; greet call chain\nselector = new_selector([my_app, greet])\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def new_selector(items: SEL, impl: str = \"\") -&gt; Selector:\n    \"\"\"Create a Selector from a list of selector inputs.\n\n    Convenience function that converts a list of various selector inputs\n    into SelectorItems and creates a Selector.\n\n    Args:\n        items: List of selector inputs (functions, classes, etc.)\n        impl: Optional implementation identifier string\n\n    Returns:\n        Selector instance with converted SelectorItems\n\n    Example:\n        ```python\n        # Create selector for my_app -&gt; greet call chain\n        selector = new_selector([my_app, greet])\n        ```\n    \"\"\"\n    sel_items = [new_selector_item(i) for i in items]\n    return Selector(sel_items, impl)\n</code></pre>"},{"location":"modules/#pychoice.funcs.new_selector_item","title":"<code>new_selector_item(item)</code>","text":"<p>Create a SelectorItem from various input types.</p> <p>This factory function converts different types of selector inputs into appropriate SelectorItem instances for use in Selectors.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>SEL_I</code> <p>Input item to convert (function, class, tuple, etc.)</p> required <p>Returns:</p> Type Description <code>SelectorItem</code> <p>Appropriate SelectorItem subclass instance</p> <p>Raises:</p> Type Description <code>InvalidSelectorItem</code> <p>If the input type cannot be converted</p> Example <pre><code># Convert function to selector item\nfunc_item = new_selector_item(my_function)\n\n# Convert class method to selector item  \nmethod_item = new_selector_item((MyClass, \"method_name\"))\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def new_selector_item(item: SEL_I) -&gt; SelectorItem:\n    \"\"\"Create a SelectorItem from various input types.\n\n    This factory function converts different types of selector inputs into\n    appropriate SelectorItem instances for use in Selectors.\n\n    Args:\n        item: Input item to convert (function, class, tuple, etc.)\n\n    Returns:\n        Appropriate SelectorItem subclass instance\n\n    Raises:\n        InvalidSelectorItem: If the input type cannot be converted\n\n    Example:\n        ```python\n        # Convert function to selector item\n        func_item = new_selector_item(my_function)\n\n        # Convert class method to selector item  \n        method_item = new_selector_item((MyClass, \"method_name\"))\n        ```\n    \"\"\"\n    if isinstance(item, type) and issubclass(item, ChoiceContext):\n        return ChoiceContextSelectorItem(item)\n    elif isinstance(item, tuple) and len(item) == 2 and isinstance(item[0], type) and isinstance(item[1], str):\n        return ClassSelectorItem(item[0], item[1])\n    elif isinstance(item, SelectorItem):\n        return item\n    elif callable(item) and hasattr(item, \"__code__\"):\n        return FunctionSelectorItem(item)\n    elif callable(item):\n        return CallableSelectorItem(item)\n    else:\n        raise InvalidSelectorItem(item)\n</code></pre>"},{"location":"modules/#pychoice.funcs.rule","title":"<code>rule(selector, impl, **kwargs)</code>","text":"<p>Create a choice rule that customizes function behavior in specific contexts.</p> <p>Rules define when and how to customize choice functions. They specify a selector (which determines when the rule applies) and either an alternative implementation or parameter overrides.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>SEL</code> <p>List defining the call stack pattern to match</p> required <code>impl</code> <code>ChoiceFunction | ChoiceFuncImplementation | None</code> <p>ChoiceFunction, ChoiceFuncImplementation, or None for parameter-only rules</p> required <code>**kwargs</code> <code>Any</code> <p>Parameter values to apply when this rule matches</p> <code>{}</code> Example <pre><code># Parameter-only rule\nchoice.rule([my_app, greet], greet, greeting=\"Hi\")\n\n# Implementation-switching rule\nchoice.rule([formal_context, greet], formal_greet_impl)\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def rule(selector: SEL, impl: ChoiceFunction | ChoiceFuncImplementation | None, **kwargs: Any) -&gt; None:\n    \"\"\"Create a choice rule that customizes function behavior in specific contexts.\n\n    Rules define when and how to customize choice functions. They specify a selector\n    (which determines when the rule applies) and either an alternative implementation\n    or parameter overrides.\n\n    Args:\n        selector: List defining the call stack pattern to match\n        impl: ChoiceFunction, ChoiceFuncImplementation, or None for parameter-only rules\n        **kwargs: Parameter values to apply when this rule matches\n\n    Example:\n        ```python\n        # Parameter-only rule\n        choice.rule([my_app, greet], greet, greeting=\"Hi\")\n\n        # Implementation-switching rule\n        choice.rule([formal_context, greet], formal_greet_impl)\n        ```\n    \"\"\"\n    if impl is None:\n        # Allow None implementation for args-only rules\n        processed_impl = None\n    elif isinstance(impl, ChoiceFunction):\n        processed_impl = impl.interface\n    elif isinstance(impl, ChoiceFuncImplementation):\n        processed_impl = impl\n    else:\n        raise NonRule()\n    # Choose function implementation\n    sel = new_selector(selector, str(processed_impl) if processed_impl is not None else \"\")\n    choice_fun = sel.choice_function()\n    if isinstance(choice_fun, ChoiceFunction):\n        choice_fun = cast(ChoiceFunction, choice_fun)\n    else:\n        raise TypeError()\n    choice_fun._add_rule(Rule(sel, processed_impl, lambda _: (processed_impl, kwargs)))\n</code></pre>"},{"location":"modules/#pychoice.funcs.wrap","title":"<code>wrap(f, implements, args=None)</code>","text":"<p>Convert an existing function into a choice function implementation.</p> <p>This is a non-decorator alternative to @impl for when you want to convert an existing function into a choice implementation.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[..., O]</code> <p>The function to convert</p> required <code>implements</code> <code>ChoiceFunction[O]</code> <p>The ChoiceFunction this will implement</p> required <code>args</code> <code>list[str] | None</code> <p>List of parameter names this implementation accepts</p> <code>None</code> <p>Returns:</p> Type Description <code>ChoiceFuncImplementation[O]</code> <p>ChoiceFuncImplementation wrapping the provided function</p> Example <pre><code>def existing_greet(name: str, style=\"casual\"):\n    return f\"Hey {name}!\"\n\ncasual_impl = choice.wrap(existing_greet, greet, args=[\"style\"])\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def wrap[O](\n    f: Callable[..., O], implements: ChoiceFunction[O], args: list[str] | None = None\n) -&gt; ChoiceFuncImplementation[O]:\n    \"\"\"Convert an existing function into a choice function implementation.\n\n    This is a non-decorator alternative to @impl for when you want to convert\n    an existing function into a choice implementation.\n\n    Args:\n        f: The function to convert\n        implements: The ChoiceFunction this will implement\n        args: List of parameter names this implementation accepts\n\n    Returns:\n        ChoiceFuncImplementation wrapping the provided function\n\n    Example:\n        ```python\n        def existing_greet(name: str, style=\"casual\"):\n            return f\"Hey {name}!\"\n\n        casual_impl = choice.wrap(existing_greet, greet, args=[\"style\"])\n        ```\n    \"\"\"\n    return impl(implements, args=args)(f)\n</code></pre>"},{"location":"modules/#arguments-and-rules-module","title":"Arguments and Rules Module","text":"<p>Core argument handling and rule management for PyChoice.</p> <p>This module contains the fundamental classes for defining and managing choice rules, selectors, and implementations. It handles the logic for matching selectors against call stacks and applying the appropriate implementations.</p>"},{"location":"modules/#pychoice.args.ChoiceFuncImplementation","title":"<code>ChoiceFuncImplementation</code>","text":"<p>Implementation wrapper for choice functions.</p> <p>This class wraps a regular function to make it usable as a choice function implementation, handling parameter validation, rule application, and invocation.</p> <p>Attributes:</p> Name Type Description <code>id</code> <p>Unique identifier for this implementation</p> <code>func</code> <code>Callable[..., O]</code> <p>The wrapped function</p> <code>defaults</code> <p>Default parameter values from the function signature</p> Example <pre><code># Create an implementation for a greeting function\nimpl = ChoiceFuncImplementation([\"greeting\"], greet_func)\nresult = impl(matched_rules, (\"John\",), {})\n</code></pre> Source code in <code>pychoice/args.py</code> <pre><code>class ChoiceFuncImplementation[O]:\n    \"\"\"Implementation wrapper for choice functions.\n\n    This class wraps a regular function to make it usable as a choice function\n    implementation, handling parameter validation, rule application, and invocation.\n\n    Attributes:\n        id: Unique identifier for this implementation\n        func: The wrapped function\n        defaults: Default parameter values from the function signature\n\n    Example:\n        ```python\n        # Create an implementation for a greeting function\n        impl = ChoiceFuncImplementation([\"greeting\"], greet_func)\n        result = impl(matched_rules, (\"John\",), {})\n        ```\n    \"\"\"\n    def __init__(self, choice_args: list[str], func: F):\n        \"\"\"Initialize a choice function implementation.\n\n        Args:\n            choice_args: List of parameter names that can be customized by rules\n            func: The function to wrap as a choice implementation\n\n        Raises:\n            MissingChoiceArg: If any choice_arg is not a parameter of func\n        \"\"\"\n        self.id = uuid5(UUID_NAMESPACE, f\"{func.__module__}.{func.__name__}\")\n        self.func: Callable[..., O] = func\n\n        # Collect args\n        sig = inspect.signature(func)\n        defaults = {}\n        for param in sig.parameters.values():\n            if param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD:\n                defaults[param.name] = param.default\n\n        # Validate args\n        for choice_arg in choice_args:\n            if choice_arg not in defaults:\n                raise MissingChoiceArg(func, choice_arg)\n        self.defaults = defaults\n\n    def choice_kwargs(self, rules: list[MatchedRule], args: tuple[Any, ...], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Merge rule values with provided kwargs.\n\n        Args:\n            rules: List of matched rules to apply\n            args: Positional arguments (unused but kept for consistency)\n            kwargs: Keyword arguments from the call\n\n        Returns:\n            Merged dictionary of keyword arguments with rule values applied\n        \"\"\"\n        new_kwargs = {}\n        for r in rules:\n            new_kwargs.update(r.vals)\n        new_kwargs.update(kwargs)\n        return new_kwargs\n\n    def __call__(self, rules: list[MatchedRule], args: tuple[Any, ...], kwargs: dict[str, Any]) -&gt; O:\n        \"\"\"Execute the implementation with rule-modified parameters.\n\n        Args:\n            rules: List of matched rules to apply\n            args: Positional arguments to pass to the function\n            kwargs: Keyword arguments to pass to the function\n\n        Returns:\n            Result of calling the wrapped function with modified parameters\n        \"\"\"\n        return self.func(*args, **self.choice_kwargs(rules, args, kwargs))\n\n    def __str__(self) -&gt; str:\n        return self.func.__name__\n</code></pre>"},{"location":"modules/#pychoice.args.ChoiceFuncImplementation.__call__","title":"<code>__call__(rules, args, kwargs)</code>","text":"<p>Execute the implementation with rule-modified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>rules</code> <code>list[MatchedRule]</code> <p>List of matched rules to apply</p> required <code>args</code> <code>tuple[Any, ...]</code> <p>Positional arguments to pass to the function</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments to pass to the function</p> required <p>Returns:</p> Type Description <code>O</code> <p>Result of calling the wrapped function with modified parameters</p> Source code in <code>pychoice/args.py</code> <pre><code>def __call__(self, rules: list[MatchedRule], args: tuple[Any, ...], kwargs: dict[str, Any]) -&gt; O:\n    \"\"\"Execute the implementation with rule-modified parameters.\n\n    Args:\n        rules: List of matched rules to apply\n        args: Positional arguments to pass to the function\n        kwargs: Keyword arguments to pass to the function\n\n    Returns:\n        Result of calling the wrapped function with modified parameters\n    \"\"\"\n    return self.func(*args, **self.choice_kwargs(rules, args, kwargs))\n</code></pre>"},{"location":"modules/#pychoice.args.ChoiceFuncImplementation.__init__","title":"<code>__init__(choice_args, func)</code>","text":"<p>Initialize a choice function implementation.</p> <p>Parameters:</p> Name Type Description Default <code>choice_args</code> <code>list[str]</code> <p>List of parameter names that can be customized by rules</p> required <code>func</code> <code>F</code> <p>The function to wrap as a choice implementation</p> required <p>Raises:</p> Type Description <code>MissingChoiceArg</code> <p>If any choice_arg is not a parameter of func</p> Source code in <code>pychoice/args.py</code> <pre><code>def __init__(self, choice_args: list[str], func: F):\n    \"\"\"Initialize a choice function implementation.\n\n    Args:\n        choice_args: List of parameter names that can be customized by rules\n        func: The function to wrap as a choice implementation\n\n    Raises:\n        MissingChoiceArg: If any choice_arg is not a parameter of func\n    \"\"\"\n    self.id = uuid5(UUID_NAMESPACE, f\"{func.__module__}.{func.__name__}\")\n    self.func: Callable[..., O] = func\n\n    # Collect args\n    sig = inspect.signature(func)\n    defaults = {}\n    for param in sig.parameters.values():\n        if param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD:\n            defaults[param.name] = param.default\n\n    # Validate args\n    for choice_arg in choice_args:\n        if choice_arg not in defaults:\n            raise MissingChoiceArg(func, choice_arg)\n    self.defaults = defaults\n</code></pre>"},{"location":"modules/#pychoice.args.ChoiceFuncImplementation.choice_kwargs","title":"<code>choice_kwargs(rules, args, kwargs)</code>","text":"<p>Merge rule values with provided kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>rules</code> <code>list[MatchedRule]</code> <p>List of matched rules to apply</p> required <code>args</code> <code>tuple[Any, ...]</code> <p>Positional arguments (unused but kept for consistency)</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments from the call</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Merged dictionary of keyword arguments with rule values applied</p> Source code in <code>pychoice/args.py</code> <pre><code>def choice_kwargs(self, rules: list[MatchedRule], args: tuple[Any, ...], kwargs: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Merge rule values with provided kwargs.\n\n    Args:\n        rules: List of matched rules to apply\n        args: Positional arguments (unused but kept for consistency)\n        kwargs: Keyword arguments from the call\n\n    Returns:\n        Merged dictionary of keyword arguments with rule values applied\n    \"\"\"\n    new_kwargs = {}\n    for r in rules:\n        new_kwargs.update(r.vals)\n    new_kwargs.update(kwargs)\n    return new_kwargs\n</code></pre>"},{"location":"modules/#pychoice.args.MatchedRule","title":"<code>MatchedRule</code>","text":"<p>Represents a rule that has been matched against a call stack.</p> <p>When a Selector matches a call stack, it creates a MatchedRule containing the original rule, captured variables, and resolved implementation details.</p> <p>Attributes:</p> Name Type Description <code>rule</code> <p>The original Rule that was matched</p> <code>captures</code> <p>List of variable dictionaries captured from matching stack frames</p> <code>impl</code> <code>ChoiceFuncImplementation | None</code> <p>The resolved ChoiceFuncImplementation to use</p> <code>vals</code> <code>dict[str, Any]</code> <p>The resolved parameter values to apply</p> Example <pre><code># When a rule matches, it becomes a MatchedRule\nmatched = MatchedRule(rule, captured_vars)\n# matched.impl contains the implementation to use\n# matched.vals contains the parameter overrides\n</code></pre> Source code in <code>pychoice/args.py</code> <pre><code>class MatchedRule:\n    \"\"\"Represents a rule that has been matched against a call stack.\n\n    When a Selector matches a call stack, it creates a MatchedRule containing\n    the original rule, captured variables, and resolved implementation details.\n\n    Attributes:\n        rule: The original Rule that was matched\n        captures: List of variable dictionaries captured from matching stack frames\n        impl: The resolved ChoiceFuncImplementation to use\n        vals: The resolved parameter values to apply\n\n    Example:\n        ```python\n        # When a rule matches, it becomes a MatchedRule\n        matched = MatchedRule(rule, captured_vars)\n        # matched.impl contains the implementation to use\n        # matched.vals contains the parameter overrides\n        ```\n    \"\"\"\n    def __init__(self, rule: Rule | None, captures: list[dict[str, Any]]) -&gt; None:\n        if rule is None:\n            rule = Rule(Selector([]), None, lambda c: None)\n        self.rule = rule\n        self.captures = captures\n\n        vals = rule.vals(captures)\n        if vals is not None:\n            self.impl: ChoiceFuncImplementation | None = vals[0]\n            self.vals: dict[str, Any] = vals[1]\n        else:\n            self.impl = None\n            self.vals = {}\n</code></pre>"},{"location":"modules/#pychoice.args.MissingChoiceArg","title":"<code>MissingChoiceArg</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a choice function is missing expected arguments.</p> <p>This occurs when a @choice.func decorator specifies choice arguments that don't exist as parameters in the decorated function.</p> Example <pre><code>@choice.func(args=[\"nonexistent\"])  # This arg doesn't exist\ndef greet(name: str):  # Missing \"nonexistent\" parameter\n    return f\"Hello {name}\"\n# Raises MissingChoiceArg\n</code></pre> Source code in <code>pychoice/args.py</code> <pre><code>class MissingChoiceArg(Exception):\n    \"\"\"Exception raised when a choice function is missing expected arguments.\n\n    This occurs when a @choice.func decorator specifies choice arguments that\n    don't exist as parameters in the decorated function.\n\n    Example:\n        ```python\n        @choice.func(args=[\"nonexistent\"])  # This arg doesn't exist\n        def greet(name: str):  # Missing \"nonexistent\" parameter\n            return f\"Hello {name}\"\n        # Raises MissingChoiceArg\n        ```\n    \"\"\"\n    def __init__(self, func: Callable[..., Any], choice_arg: str):\n        msg = f\"The function {func.__name__} is missing the expected choice kwarg {choice_arg}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"modules/#pychoice.args.Rule","title":"<code>Rule</code>  <code>dataclass</code>","text":"<p>Represents a choice rule that defines when and how to customize function behavior.</p> <p>A Rule combines a Selector (which defines when the rule applies) with an  implementation and values (which define how to customize the behavior).</p> <p>Attributes:</p> Name Type Description <code>selector</code> <code>Selector</code> <p>The Selector that determines when this rule matches</p> <code>impl</code> <code>ChoiceFuncImplementation | None</code> <p>The ChoiceFuncImplementation to use, or None for parameter-only rules</p> <code>vals</code> <code>RuleVals</code> <p>Function that converts captures to implementation and values</p> <code>doc</code> <code>str | None</code> <p>Optional documentation string for the rule</p> Example <pre><code># Rule that changes greeting in my_app context\nrule = Rule(\n    selector=Selector([my_app, greet]),\n    impl=greet_impl,\n    vals=lambda c: (greet_impl, {\"greeting\": \"Hi\"})\n)\n</code></pre> Source code in <code>pychoice/args.py</code> <pre><code>@dataclass\nclass Rule:\n    \"\"\"Represents a choice rule that defines when and how to customize function behavior.\n\n    A Rule combines a Selector (which defines when the rule applies) with an \n    implementation and values (which define how to customize the behavior).\n\n    Attributes:\n        selector: The Selector that determines when this rule matches\n        impl: The ChoiceFuncImplementation to use, or None for parameter-only rules\n        vals: Function that converts captures to implementation and values\n        doc: Optional documentation string for the rule\n\n    Example:\n        ```python\n        # Rule that changes greeting in my_app context\n        rule = Rule(\n            selector=Selector([my_app, greet]),\n            impl=greet_impl,\n            vals=lambda c: (greet_impl, {\"greeting\": \"Hi\"})\n        )\n        ```\n    \"\"\"\n    selector: Selector\n    impl: ChoiceFuncImplementation | None\n    vals: RuleVals\n    doc: str | None = None\n\n    def __str__(self) -&gt; str:\n        if self.impl is not None:\n            return f\"{self.selector} [{self.impl.func.__name__}]\"\n        else:\n            return f\"{self.selector}\"\n</code></pre>"},{"location":"modules/#pychoice.args.Selector","title":"<code>Selector</code>","text":"<p>Defines a pattern for matching against function call stacks.</p> <p>A Selector contains a list of SelectorItems that must match in order from the deepest to shallowest call stack frames. It's used to determine when choice rules should be applied.</p> <p>Attributes:</p> Name Type Description <code>items</code> <code>list[SelectorItem]</code> <p>List of SelectorItems that define the matching pattern</p> <code>impl</code> <p>Implementation identifier string for display purposes</p> Example <pre><code># Match when greet() is called from my_app()\nselector = Selector([my_app, greet])\n</code></pre> Source code in <code>pychoice/args.py</code> <pre><code>class Selector:\n    \"\"\"Defines a pattern for matching against function call stacks.\n\n    A Selector contains a list of SelectorItems that must match in order\n    from the deepest to shallowest call stack frames. It's used to determine\n    when choice rules should be applied.\n\n    Attributes:\n        items: List of SelectorItems that define the matching pattern\n        impl: Implementation identifier string for display purposes\n\n    Example:\n        ```python\n        # Match when greet() is called from my_app()\n        selector = Selector([my_app, greet])\n        ```\n    \"\"\"\n    def __init__(self, items: list[SelectorItem], impl: str = \"\") -&gt; None:\n        self.items: list[SelectorItem] = items\n        self.impl = impl\n\n    def __str__(self) -&gt; str:\n        return f\"{' '.join(str(i) for i in self.items)} =&gt; {self.impl}\"\n\n    def choice_function(self) -&gt; Any:\n        \"\"\"Get the choice function that this selector targets.\n\n        Returns:\n            The callable from the last SelectorItem, typically a choice function\n        \"\"\"\n        return self.items[-1].get_callable()\n\n    @staticmethod\n    def sort(selectors: list[Selector]) -&gt; list[int]:\n        \"\"\"Sort selectors by specificity, returning indices.\n\n        Returns indices of selectors sorted from least specific (0) to most \n        specific (-1). Non-matching selectors are excluded.\n\n        Args:\n            selectors: List of selectors to sort\n\n        Returns:\n            List of indices in specificity order (most specific last)\n        \"\"\"\n        if not selectors:\n            return []\n        stack_info = inspect.stack()\n\n        # Get indices and filter to only matching\n        indices = [i for i, matches in enumerate(Selector.all_matches(selectors, stack_info)) if matches]\n\n        def compare(a: int, b: int) -&gt; int:\n            return selectors[a].compare(selectors[b], stack_info)\n\n        # Sort\n        return sorted(indices, key=cmp_to_key(compare))\n\n    @staticmethod\n    def all_matches(selectors: list[Selector], stack_info: OptStackFrame = None) -&gt; list[bool]:\n        \"\"\"Check which selectors match the current call stack.\n\n        Args:\n            selectors: List of selectors to check\n            stack_info: Optional stack frames, uses current stack if None\n\n        Returns:\n            Boolean list indicating which selectors match\n        \"\"\"\n        if not selectors:\n            return []\n        if stack_info is None:\n            stack_info = inspect.stack()\n        return [selector.matches(stack_info) is not None for selector in selectors]\n\n    def matches(self, stack_info: OptStackFrame = None, rule: Rule | None = None) -&gt; MatchedRule | None:\n        \"\"\"Check if this selector matches the given call stack.\n\n        Args:\n            stack_info: Stack frames to match against, uses current if None\n            rule: Associated rule for creating MatchedRule\n\n        Returns:\n            MatchedRule if selector matches, None otherwise\n        \"\"\"\n        if stack_info is None:\n            stack_info = inspect.stack()\n        if len(self.items) == 0:\n            # Empty selector always matches\n            return MatchedRule(rule, [])\n\n        captures = []\n        selector_index = len(self.items) - 1\n        for frame_info in stack_info:\n            if self.items[selector_index].matches(frame_info):\n                captures.append(Selector._collect_captures(self.items[selector_index], frame_info))\n                if selector_index == 0:\n                    return MatchedRule(rule, list(reversed(captures)))\n                else:\n                    # More selector components\n                    selector_index = selector_index - 1\n        return None\n\n    @staticmethod\n    def _collect_captures(item: SelectorItem, frame_info: inspect.FrameInfo) -&gt; dict[str, Any]:\n        \"\"\"Collect variable captures from a matching stack frame.\n\n        Args:\n            item: The SelectorItem that matched\n            frame_info: The stack frame that was matched\n\n        Returns:\n            Dictionary of captured local variables\n        \"\"\"\n        # Import Match here to avoid circular imports\n        from .funcs import CallableSelectorItem, ChoiceFunction\n\n        # Capture logic moved from Match.capture\n        local_vars = frame_info.frame.f_locals\n\n        # Check if we're in a ChoiceFunction.__call__ context\n        if isinstance(item, CallableSelectorItem) and isinstance(item.func, ChoiceFunction):\n            choice_func = local_vars[\"self\"]\n            args = local_vars.get(\"args\", ())\n            kwargs = local_vars.get(\"kwargs\", {})\n\n            # Get the signature of the actual function\n            sig = inspect.signature(choice_func.interface.func)\n\n            # Bind the arguments to get the actual parameter values\n            try:\n                bound_args = sig.bind(*args, **kwargs)\n                bound_args.apply_defaults()\n\n                # Return only the requested match_args\n                return dict(bound_args.arguments)\n            except Exception:  # noqa: S110\n                # Fall back to original behavior if binding fails\n                pass\n\n        # Original behavior for regular functions\n        return dict(local_vars)\n\n    def compare(self, other: Selector, stack_info: StackFrame) -&gt; int:\n        \"\"\"Compare selector specificity for a given call stack.\n\n        Args:\n            other: Other selector to compare against\n            stack_info: Call stack to compare within\n\n        Returns:\n            -1 if self is less specific, 1 if more specific, 0 if equal\n        \"\"\"\n        a = self.items\n        b = other.items\n        a_selector_index = len(a) - 1\n        b_selector_index = len(b) - 1\n        for frame_info in stack_info:\n            if a_selector_index &lt; 0 and b_selector_index &lt; 0:\n                return 0\n            elif a_selector_index &lt; 0:\n                return -1\n            elif b_selector_index &lt; 0:\n                return 1\n            a_matches = a[a_selector_index].matches(frame_info)\n            b_matches = b[b_selector_index].matches(frame_info)\n            if not a_matches and not b_matches:\n                # Check next frame\n                continue\n            elif a_matches and b_matches:\n                a_selector_index = a_selector_index - 1\n                b_selector_index = b_selector_index - 1\n            elif not a_matches and b_matches:\n                # b has lower level match, takes precedence\n                return -1\n            elif a_matches and not b_matches:\n                # a has lower level match, takes precedence\n                return 1\n        return 0\n\n    def generic_compare(self, other: Selector) -&gt; int:\n        \"\"\"Compare selectors generically without specific call stack context.\n\n        Args:\n            other: Other selector to compare against\n\n        Returns:\n            -1 if self is sub-selector of other, 1 if other is sub-selector of self, 0 if no relation\n        \"\"\"\n        a = self.items\n        b = other.items\n        a_selector_index = len(a) - 1\n        b_selector_index = len(b) - 1\n        while a_selector_index &gt;= 0 and b_selector_index &gt;= 0:\n            if a[a_selector_index] == b[b_selector_index]:\n                a_selector_index = a_selector_index - 1\n                b_selector_index = b_selector_index - 1\n            else:\n                # Term mismatch. No sub_selector relation\n                return 0\n\n        if a_selector_index &gt;= 0:\n            return -1\n        if b_selector_index &gt;= 0:\n            return 1\n\n        # Selectors are equal\n        return 0\n</code></pre>"},{"location":"modules/#pychoice.args.Selector.all_matches","title":"<code>all_matches(selectors, stack_info=None)</code>  <code>staticmethod</code>","text":"<p>Check which selectors match the current call stack.</p> <p>Parameters:</p> Name Type Description Default <code>selectors</code> <code>list[Selector]</code> <p>List of selectors to check</p> required <code>stack_info</code> <code>OptStackFrame</code> <p>Optional stack frames, uses current stack if None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[bool]</code> <p>Boolean list indicating which selectors match</p> Source code in <code>pychoice/args.py</code> <pre><code>@staticmethod\ndef all_matches(selectors: list[Selector], stack_info: OptStackFrame = None) -&gt; list[bool]:\n    \"\"\"Check which selectors match the current call stack.\n\n    Args:\n        selectors: List of selectors to check\n        stack_info: Optional stack frames, uses current stack if None\n\n    Returns:\n        Boolean list indicating which selectors match\n    \"\"\"\n    if not selectors:\n        return []\n    if stack_info is None:\n        stack_info = inspect.stack()\n    return [selector.matches(stack_info) is not None for selector in selectors]\n</code></pre>"},{"location":"modules/#pychoice.args.Selector.choice_function","title":"<code>choice_function()</code>","text":"<p>Get the choice function that this selector targets.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The callable from the last SelectorItem, typically a choice function</p> Source code in <code>pychoice/args.py</code> <pre><code>def choice_function(self) -&gt; Any:\n    \"\"\"Get the choice function that this selector targets.\n\n    Returns:\n        The callable from the last SelectorItem, typically a choice function\n    \"\"\"\n    return self.items[-1].get_callable()\n</code></pre>"},{"location":"modules/#pychoice.args.Selector.compare","title":"<code>compare(other, stack_info)</code>","text":"<p>Compare selector specificity for a given call stack.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Selector</code> <p>Other selector to compare against</p> required <code>stack_info</code> <code>StackFrame</code> <p>Call stack to compare within</p> required <p>Returns:</p> Type Description <code>int</code> <p>-1 if self is less specific, 1 if more specific, 0 if equal</p> Source code in <code>pychoice/args.py</code> <pre><code>def compare(self, other: Selector, stack_info: StackFrame) -&gt; int:\n    \"\"\"Compare selector specificity for a given call stack.\n\n    Args:\n        other: Other selector to compare against\n        stack_info: Call stack to compare within\n\n    Returns:\n        -1 if self is less specific, 1 if more specific, 0 if equal\n    \"\"\"\n    a = self.items\n    b = other.items\n    a_selector_index = len(a) - 1\n    b_selector_index = len(b) - 1\n    for frame_info in stack_info:\n        if a_selector_index &lt; 0 and b_selector_index &lt; 0:\n            return 0\n        elif a_selector_index &lt; 0:\n            return -1\n        elif b_selector_index &lt; 0:\n            return 1\n        a_matches = a[a_selector_index].matches(frame_info)\n        b_matches = b[b_selector_index].matches(frame_info)\n        if not a_matches and not b_matches:\n            # Check next frame\n            continue\n        elif a_matches and b_matches:\n            a_selector_index = a_selector_index - 1\n            b_selector_index = b_selector_index - 1\n        elif not a_matches and b_matches:\n            # b has lower level match, takes precedence\n            return -1\n        elif a_matches and not b_matches:\n            # a has lower level match, takes precedence\n            return 1\n    return 0\n</code></pre>"},{"location":"modules/#pychoice.args.Selector.generic_compare","title":"<code>generic_compare(other)</code>","text":"<p>Compare selectors generically without specific call stack context.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Selector</code> <p>Other selector to compare against</p> required <p>Returns:</p> Type Description <code>int</code> <p>-1 if self is sub-selector of other, 1 if other is sub-selector of self, 0 if no relation</p> Source code in <code>pychoice/args.py</code> <pre><code>def generic_compare(self, other: Selector) -&gt; int:\n    \"\"\"Compare selectors generically without specific call stack context.\n\n    Args:\n        other: Other selector to compare against\n\n    Returns:\n        -1 if self is sub-selector of other, 1 if other is sub-selector of self, 0 if no relation\n    \"\"\"\n    a = self.items\n    b = other.items\n    a_selector_index = len(a) - 1\n    b_selector_index = len(b) - 1\n    while a_selector_index &gt;= 0 and b_selector_index &gt;= 0:\n        if a[a_selector_index] == b[b_selector_index]:\n            a_selector_index = a_selector_index - 1\n            b_selector_index = b_selector_index - 1\n        else:\n            # Term mismatch. No sub_selector relation\n            return 0\n\n    if a_selector_index &gt;= 0:\n        return -1\n    if b_selector_index &gt;= 0:\n        return 1\n\n    # Selectors are equal\n    return 0\n</code></pre>"},{"location":"modules/#pychoice.args.Selector.matches","title":"<code>matches(stack_info=None, rule=None)</code>","text":"<p>Check if this selector matches the given call stack.</p> <p>Parameters:</p> Name Type Description Default <code>stack_info</code> <code>OptStackFrame</code> <p>Stack frames to match against, uses current if None</p> <code>None</code> <code>rule</code> <code>Rule | None</code> <p>Associated rule for creating MatchedRule</p> <code>None</code> <p>Returns:</p> Type Description <code>MatchedRule | None</code> <p>MatchedRule if selector matches, None otherwise</p> Source code in <code>pychoice/args.py</code> <pre><code>def matches(self, stack_info: OptStackFrame = None, rule: Rule | None = None) -&gt; MatchedRule | None:\n    \"\"\"Check if this selector matches the given call stack.\n\n    Args:\n        stack_info: Stack frames to match against, uses current if None\n        rule: Associated rule for creating MatchedRule\n\n    Returns:\n        MatchedRule if selector matches, None otherwise\n    \"\"\"\n    if stack_info is None:\n        stack_info = inspect.stack()\n    if len(self.items) == 0:\n        # Empty selector always matches\n        return MatchedRule(rule, [])\n\n    captures = []\n    selector_index = len(self.items) - 1\n    for frame_info in stack_info:\n        if self.items[selector_index].matches(frame_info):\n            captures.append(Selector._collect_captures(self.items[selector_index], frame_info))\n            if selector_index == 0:\n                return MatchedRule(rule, list(reversed(captures)))\n            else:\n                # More selector components\n                selector_index = selector_index - 1\n    return None\n</code></pre>"},{"location":"modules/#pychoice.args.Selector.sort","title":"<code>sort(selectors)</code>  <code>staticmethod</code>","text":"<p>Sort selectors by specificity, returning indices.</p> <p>Returns indices of selectors sorted from least specific (0) to most  specific (-1). Non-matching selectors are excluded.</p> <p>Parameters:</p> Name Type Description Default <code>selectors</code> <code>list[Selector]</code> <p>List of selectors to sort</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>List of indices in specificity order (most specific last)</p> Source code in <code>pychoice/args.py</code> <pre><code>@staticmethod\ndef sort(selectors: list[Selector]) -&gt; list[int]:\n    \"\"\"Sort selectors by specificity, returning indices.\n\n    Returns indices of selectors sorted from least specific (0) to most \n    specific (-1). Non-matching selectors are excluded.\n\n    Args:\n        selectors: List of selectors to sort\n\n    Returns:\n        List of indices in specificity order (most specific last)\n    \"\"\"\n    if not selectors:\n        return []\n    stack_info = inspect.stack()\n\n    # Get indices and filter to only matching\n    indices = [i for i, matches in enumerate(Selector.all_matches(selectors, stack_info)) if matches]\n\n    def compare(a: int, b: int) -&gt; int:\n        return selectors[a].compare(selectors[b], stack_info)\n\n    # Sort\n    return sorted(indices, key=cmp_to_key(compare))\n</code></pre>"},{"location":"modules/#selector-classes-module","title":"Selector Classes Module","text":"<p>Selector system for PyChoice - matching patterns against call stacks.</p> <p>This module provides the selector system used by PyChoice to match patterns against function call stacks. It includes various types of selector items that can match different kinds of callables (functions, methods, contexts) and the infrastructure for managing choice contexts.</p>"},{"location":"modules/#pychoice.selector.CallableSelectorItem","title":"<code>CallableSelectorItem</code>","text":"<p>               Bases: <code>SelectorItem</code></p> <p>Selector item that matches callable objects (including choice functions).</p> <p>This selector handles callable objects that may not be simple functions, such as choice functions, lambdas, or objects with call methods.</p> <p>Attributes:</p> Name Type Description <code>func</code> <code>Callable[..., Any]</code> <p>The callable object to match against</p> Example <pre><code>@choice.func()\ndef my_choice_func():\n    pass\n\ncallable_selector = CallableSelectorItem(my_choice_func)\n# Matches stack frames executing the choice function\n</code></pre> Source code in <code>pychoice/selector.py</code> <pre><code>class CallableSelectorItem(SelectorItem):\n    \"\"\"Selector item that matches callable objects (including choice functions).\n\n    This selector handles callable objects that may not be simple functions,\n    such as choice functions, lambdas, or objects with __call__ methods.\n\n    Attributes:\n        func: The callable object to match against\n\n    Example:\n        ```python\n        @choice.func()\n        def my_choice_func():\n            pass\n\n        callable_selector = CallableSelectorItem(my_choice_func)\n        # Matches stack frames executing the choice function\n        ```\n    \"\"\"\n    def __init__(self, func: Callable[..., Any]):\n        \"\"\"Initialize with a callable to match.\n\n        Args:\n            func: The callable object that this selector should match\n        \"\"\"\n        self.func: Callable[..., Any] = func\n\n    def __str__(self) -&gt; str:\n        return self.func.__name__\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, CallableSelectorItem) and self.func == other.func\n\n    def get_callable(self) -&gt; Callable[..., Any] | None:\n        \"\"\"Return the callable this selector represents.\"\"\"\n        return self.func\n\n    def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n        \"\"\"Check if the stack frame is executing this callable.\n\n        This method handles the complexity of matching callable objects,\n        including checking code objects and instance matching for methods.\n\n        Args:\n            frame_info: Stack frame to check\n\n        Returns:\n            True if the frame is executing this callable, False otherwise\n        \"\"\"\n        if not hasattr(self.func.__call__, \"__code__\"):  # type: ignore[operator]\n            return False\n        if self.func.__call__.__code__ != frame_info.frame.f_code:  # type: ignore[operator]\n            return False\n        return not (hasattr(self.func, \"__class__\") and self.func != frame_info.frame.f_locals.get(\"self\", None))\n</code></pre>"},{"location":"modules/#pychoice.selector.CallableSelectorItem.__init__","title":"<code>__init__(func)</code>","text":"<p>Initialize with a callable to match.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>The callable object that this selector should match</p> required Source code in <code>pychoice/selector.py</code> <pre><code>def __init__(self, func: Callable[..., Any]):\n    \"\"\"Initialize with a callable to match.\n\n    Args:\n        func: The callable object that this selector should match\n    \"\"\"\n    self.func: Callable[..., Any] = func\n</code></pre>"},{"location":"modules/#pychoice.selector.CallableSelectorItem.get_callable","title":"<code>get_callable()</code>","text":"<p>Return the callable this selector represents.</p> Source code in <code>pychoice/selector.py</code> <pre><code>def get_callable(self) -&gt; Callable[..., Any] | None:\n    \"\"\"Return the callable this selector represents.\"\"\"\n    return self.func\n</code></pre>"},{"location":"modules/#pychoice.selector.CallableSelectorItem.matches","title":"<code>matches(frame_info)</code>","text":"<p>Check if the stack frame is executing this callable.</p> <p>This method handles the complexity of matching callable objects, including checking code objects and instance matching for methods.</p> <p>Parameters:</p> Name Type Description Default <code>frame_info</code> <code>FrameInfo</code> <p>Stack frame to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the frame is executing this callable, False otherwise</p> Source code in <code>pychoice/selector.py</code> <pre><code>def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n    \"\"\"Check if the stack frame is executing this callable.\n\n    This method handles the complexity of matching callable objects,\n    including checking code objects and instance matching for methods.\n\n    Args:\n        frame_info: Stack frame to check\n\n    Returns:\n        True if the frame is executing this callable, False otherwise\n    \"\"\"\n    if not hasattr(self.func.__call__, \"__code__\"):  # type: ignore[operator]\n        return False\n    if self.func.__call__.__code__ != frame_info.frame.f_code:  # type: ignore[operator]\n        return False\n    return not (hasattr(self.func, \"__class__\") and self.func != frame_info.frame.f_locals.get(\"self\", None))\n</code></pre>"},{"location":"modules/#pychoice.selector.ChoiceContext","title":"<code>ChoiceContext</code>","text":"<p>Base class for choice contexts that provide temporary rule scoping.</p> <p>ChoiceContexts allow you to create temporary scopes where specific choice rules apply. They use Python's context manager protocol and context variables to track when they are active.</p> <p>Attributes:</p> Name Type Description <code>active</code> <p>ContextVar tracking whether this context is currently active</p> Example <pre><code>class DebugContext(ChoiceContext):\n    pass\n\nwith DebugContext():\n    # Rules targeting DebugContext will apply here\n    my_function()  # May use different implementation\n</code></pre> Source code in <code>pychoice/selector.py</code> <pre><code>class ChoiceContext:\n    \"\"\"Base class for choice contexts that provide temporary rule scoping.\n\n    ChoiceContexts allow you to create temporary scopes where specific choice\n    rules apply. They use Python's context manager protocol and context variables\n    to track when they are active.\n\n    Attributes:\n        active: ContextVar tracking whether this context is currently active\n\n    Example:\n        ```python\n        class DebugContext(ChoiceContext):\n            pass\n\n        with DebugContext():\n            # Rules targeting DebugContext will apply here\n            my_function()  # May use different implementation\n        ```\n    \"\"\"\n    active = ContextVar(\"active\", default=False)\n\n    def __enter__(self) -&gt; None:\n        self.active.set(True)\n\n    def __exit__(\n        self, exc_type: BaseException | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -&gt; bool | None:\n        self.active.set(False)\n        return None\n</code></pre>"},{"location":"modules/#pychoice.selector.ChoiceContextSelectorItem","title":"<code>ChoiceContextSelectorItem</code>","text":"<p>               Bases: <code>SelectorItem</code></p> <p>Selector item that matches when a specific ChoiceContext is active.</p> <p>This selector matches stack frames that occur while a particular ChoiceContext is active (i.e., within its context manager scope).</p> <p>Attributes:</p> Name Type Description <code>context</code> <p>The ChoiceContext class to check for activity</p> Example <pre><code>class DebugContext(ChoiceContext):\n    pass\n\ndebug_selector = ChoiceContextSelectorItem(DebugContext)\n# Matches when code runs within \"with DebugContext():\" blocks\n</code></pre> Source code in <code>pychoice/selector.py</code> <pre><code>class ChoiceContextSelectorItem(SelectorItem):\n    \"\"\"Selector item that matches when a specific ChoiceContext is active.\n\n    This selector matches stack frames that occur while a particular\n    ChoiceContext is active (i.e., within its context manager scope).\n\n    Attributes:\n        context: The ChoiceContext class to check for activity\n\n    Example:\n        ```python\n        class DebugContext(ChoiceContext):\n            pass\n\n        debug_selector = ChoiceContextSelectorItem(DebugContext)\n        # Matches when code runs within \"with DebugContext():\" blocks\n        ```\n    \"\"\"\n    def __init__(self, context: type[ChoiceContext]):\n        \"\"\"Initialize with a ChoiceContext class to match.\n\n        Args:\n            context: The ChoiceContext class that must be active for matching\n        \"\"\"\n        self.context = context\n\n    def __str__(self) -&gt; str:\n        return f\"ChoiceContext(active={self.context.active.get()})\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, ChoiceContextSelectorItem) and self.context == other.context\n\n    def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n        \"\"\"Check if the context is currently active.\n\n        Args:\n            frame_info: Stack frame (unused for context matching)\n\n        Returns:\n            True if the ChoiceContext is currently active, False otherwise\n        \"\"\"\n        return self.context.active.get()\n</code></pre>"},{"location":"modules/#pychoice.selector.ChoiceContextSelectorItem.__init__","title":"<code>__init__(context)</code>","text":"<p>Initialize with a ChoiceContext class to match.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>type[ChoiceContext]</code> <p>The ChoiceContext class that must be active for matching</p> required Source code in <code>pychoice/selector.py</code> <pre><code>def __init__(self, context: type[ChoiceContext]):\n    \"\"\"Initialize with a ChoiceContext class to match.\n\n    Args:\n        context: The ChoiceContext class that must be active for matching\n    \"\"\"\n    self.context = context\n</code></pre>"},{"location":"modules/#pychoice.selector.ChoiceContextSelectorItem.matches","title":"<code>matches(frame_info)</code>","text":"<p>Check if the context is currently active.</p> <p>Parameters:</p> Name Type Description Default <code>frame_info</code> <code>FrameInfo</code> <p>Stack frame (unused for context matching)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the ChoiceContext is currently active, False otherwise</p> Source code in <code>pychoice/selector.py</code> <pre><code>def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n    \"\"\"Check if the context is currently active.\n\n    Args:\n        frame_info: Stack frame (unused for context matching)\n\n    Returns:\n        True if the ChoiceContext is currently active, False otherwise\n    \"\"\"\n    return self.context.active.get()\n</code></pre>"},{"location":"modules/#pychoice.selector.ClassSelectorItem","title":"<code>ClassSelectorItem</code>","text":"<p>               Bases: <code>SelectorItem</code></p> <p>Selector item that matches specific class methods.</p> <p>This selector matches stack frames where a specific method of a specific class (or its subclasses) is being executed. It supports inheritance matching.</p> <p>Attributes:</p> Name Type Description <code>cls</code> <p>The class to match</p> <code>qual_name</code> <p>Qualified name string (ClassName.method_name)</p> <code>func_name</code> <p>Name of the method to match</p> Example <pre><code>class MyClass:\n    def my_method(self):\n        pass\n\nclass_selector = ClassSelectorItem(MyClass, \"my_method\")\n# Matches when MyClass.my_method or subclass.my_method is executing\n</code></pre> Source code in <code>pychoice/selector.py</code> <pre><code>class ClassSelectorItem(SelectorItem):\n    \"\"\"Selector item that matches specific class methods.\n\n    This selector matches stack frames where a specific method of a specific\n    class (or its subclasses) is being executed. It supports inheritance\n    matching.\n\n    Attributes:\n        cls: The class to match\n        qual_name: Qualified name string (ClassName.method_name)\n        func_name: Name of the method to match\n\n    Example:\n        ```python\n        class MyClass:\n            def my_method(self):\n                pass\n\n        class_selector = ClassSelectorItem(MyClass, \"my_method\")\n        # Matches when MyClass.my_method or subclass.my_method is executing\n        ```\n    \"\"\"\n    def __init__(self, cls: type, func_name: str):\n        \"\"\"Initialize with a class and method name to match.\n\n        Args:\n            cls: The class that must contain the method\n            func_name: Name of the method to match\n        \"\"\"\n        self.cls = cls\n        self.qual_name = f\"{cls.__name__}.{func_name}\"\n        self.func_name = func_name\n\n    def __str__(self) -&gt; str:\n        return self.qual_name\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, ClassSelectorItem) and self.cls == other.cls and self.func_name == other.func_name\n\n    def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n        \"\"\"Check if the stack frame is executing this class method.\n\n        This method checks both the method name and class hierarchy,\n        supporting inheritance matching where subclass methods match\n        their parent class selectors.\n\n        Args:\n            frame_info: Stack frame to check\n\n        Returns:\n            True if frame is executing this class method or a subclass override\n        \"\"\"\n        if frame_info.frame.f_code.co_name == self.func_name:\n            qualname = frame_info.frame.f_code.co_qualname\n            parts = qualname.split(\".\")\n            if len(parts) &gt; 1:\n                class_name = parts[0]\n                module = inspect.getmodule(frame_info.frame)\n                cls = getattr(module, class_name, None)\n                if not isinstance(cls, type):\n                    return False\n                return cls == self.cls or issubclass(cls, self.cls)\n        return False\n</code></pre>"},{"location":"modules/#pychoice.selector.ClassSelectorItem.__init__","title":"<code>__init__(cls, func_name)</code>","text":"<p>Initialize with a class and method name to match.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The class that must contain the method</p> required <code>func_name</code> <code>str</code> <p>Name of the method to match</p> required Source code in <code>pychoice/selector.py</code> <pre><code>def __init__(self, cls: type, func_name: str):\n    \"\"\"Initialize with a class and method name to match.\n\n    Args:\n        cls: The class that must contain the method\n        func_name: Name of the method to match\n    \"\"\"\n    self.cls = cls\n    self.qual_name = f\"{cls.__name__}.{func_name}\"\n    self.func_name = func_name\n</code></pre>"},{"location":"modules/#pychoice.selector.ClassSelectorItem.matches","title":"<code>matches(frame_info)</code>","text":"<p>Check if the stack frame is executing this class method.</p> <p>This method checks both the method name and class hierarchy, supporting inheritance matching where subclass methods match their parent class selectors.</p> <p>Parameters:</p> Name Type Description Default <code>frame_info</code> <code>FrameInfo</code> <p>Stack frame to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if frame is executing this class method or a subclass override</p> Source code in <code>pychoice/selector.py</code> <pre><code>def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n    \"\"\"Check if the stack frame is executing this class method.\n\n    This method checks both the method name and class hierarchy,\n    supporting inheritance matching where subclass methods match\n    their parent class selectors.\n\n    Args:\n        frame_info: Stack frame to check\n\n    Returns:\n        True if frame is executing this class method or a subclass override\n    \"\"\"\n    if frame_info.frame.f_code.co_name == self.func_name:\n        qualname = frame_info.frame.f_code.co_qualname\n        parts = qualname.split(\".\")\n        if len(parts) &gt; 1:\n            class_name = parts[0]\n            module = inspect.getmodule(frame_info.frame)\n            cls = getattr(module, class_name, None)\n            if not isinstance(cls, type):\n                return False\n            return cls == self.cls or issubclass(cls, self.cls)\n    return False\n</code></pre>"},{"location":"modules/#pychoice.selector.FunctionSelectorItem","title":"<code>FunctionSelectorItem</code>","text":"<p>               Bases: <code>SelectorItem</code></p> <p>Selector item that matches specific function calls.</p> <p>This selector matches stack frames where the executing code corresponds to a specific function object, based on code object comparison.</p> <p>Attributes:</p> Name Type Description <code>func</code> <p>The function to match against</p> Example <pre><code>def my_function():\n    pass\n\nfunc_selector = FunctionSelectorItem(my_function)\n# Matches stack frames executing my_function\n</code></pre> Source code in <code>pychoice/selector.py</code> <pre><code>class FunctionSelectorItem(SelectorItem):\n    \"\"\"Selector item that matches specific function calls.\n\n    This selector matches stack frames where the executing code corresponds\n    to a specific function object, based on code object comparison.\n\n    Attributes:\n        func: The function to match against\n\n    Example:\n        ```python\n        def my_function():\n            pass\n\n        func_selector = FunctionSelectorItem(my_function)\n        # Matches stack frames executing my_function\n        ```\n    \"\"\"\n    def __init__(self, func: Callable[..., Any]):\n        \"\"\"Initialize with a function to match.\n\n        Args:\n            func: The function that this selector should match\n        \"\"\"\n        self.func = func\n\n    def __str__(self) -&gt; str:\n        return self.func.__name__\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, FunctionSelectorItem) and self.func == other.func\n\n    def get_callable(self) -&gt; Callable[..., Any] | None:\n        \"\"\"Return the function this selector represents.\"\"\"\n        return self.func\n\n    def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n        \"\"\"Check if the stack frame is executing this function.\n\n        Args:\n            frame_info: Stack frame to check\n\n        Returns:\n            True if the frame is executing this function, False otherwise\n        \"\"\"\n        return self.func.__code__ == frame_info.frame.f_code\n</code></pre>"},{"location":"modules/#pychoice.selector.FunctionSelectorItem.__init__","title":"<code>__init__(func)</code>","text":"<p>Initialize with a function to match.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>The function that this selector should match</p> required Source code in <code>pychoice/selector.py</code> <pre><code>def __init__(self, func: Callable[..., Any]):\n    \"\"\"Initialize with a function to match.\n\n    Args:\n        func: The function that this selector should match\n    \"\"\"\n    self.func = func\n</code></pre>"},{"location":"modules/#pychoice.selector.FunctionSelectorItem.get_callable","title":"<code>get_callable()</code>","text":"<p>Return the function this selector represents.</p> Source code in <code>pychoice/selector.py</code> <pre><code>def get_callable(self) -&gt; Callable[..., Any] | None:\n    \"\"\"Return the function this selector represents.\"\"\"\n    return self.func\n</code></pre>"},{"location":"modules/#pychoice.selector.FunctionSelectorItem.matches","title":"<code>matches(frame_info)</code>","text":"<p>Check if the stack frame is executing this function.</p> <p>Parameters:</p> Name Type Description Default <code>frame_info</code> <code>FrameInfo</code> <p>Stack frame to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the frame is executing this function, False otherwise</p> Source code in <code>pychoice/selector.py</code> <pre><code>def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n    \"\"\"Check if the stack frame is executing this function.\n\n    Args:\n        frame_info: Stack frame to check\n\n    Returns:\n        True if the frame is executing this function, False otherwise\n    \"\"\"\n    return self.func.__code__ == frame_info.frame.f_code\n</code></pre>"},{"location":"modules/#pychoice.selector.InvalidSelectorItem","title":"<code>InvalidSelectorItem</code>","text":"<p>               Bases: <code>TypeError</code></p> <p>Exception raised when an invalid type is used as a selector item.</p> <p>This occurs when trying to create a SelectorItem from an object type that isn't supported by the selector system.</p> Example <pre><code># This would raise InvalidSelectorItem\nselector = Selector([my_func, 42])  # 42 is not a valid selector item\n</code></pre> Source code in <code>pychoice/selector.py</code> <pre><code>class InvalidSelectorItem(TypeError):\n    \"\"\"Exception raised when an invalid type is used as a selector item.\n\n    This occurs when trying to create a SelectorItem from an object type\n    that isn't supported by the selector system.\n\n    Example:\n        ```python\n        # This would raise InvalidSelectorItem\n        selector = Selector([my_func, 42])  # 42 is not a valid selector item\n        ```\n    \"\"\"\n    def __init__(self, item: SEL_I):\n        \"\"\"Initialize the exception with information about the invalid item.\n\n        Args:\n            item: The invalid selector item that caused the error\n        \"\"\"\n        msg = f\"Invalid selector item type: {type(item)} for {item}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"modules/#pychoice.selector.InvalidSelectorItem.__init__","title":"<code>__init__(item)</code>","text":"<p>Initialize the exception with information about the invalid item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>SEL_I</code> <p>The invalid selector item that caused the error</p> required Source code in <code>pychoice/selector.py</code> <pre><code>def __init__(self, item: SEL_I):\n    \"\"\"Initialize the exception with information about the invalid item.\n\n    Args:\n        item: The invalid selector item that caused the error\n    \"\"\"\n    msg = f\"Invalid selector item type: {type(item)} for {item}\"\n    super().__init__(msg)\n</code></pre>"},{"location":"modules/#pychoice.selector.NonFunction","title":"<code>NonFunction</code>","text":"<p>               Bases: <code>TypeError</code></p> <p>Exception raised when a non-function is used as final selector term.</p> <p>The final term in a selector must be a callable (typically a choice function) since it represents the target of the rule. This exception is raised when the final term is not callable.</p> Source code in <code>pychoice/selector.py</code> <pre><code>class NonFunction(TypeError):\n    \"\"\"Exception raised when a non-function is used as final selector term.\n\n    The final term in a selector must be a callable (typically a choice function)\n    since it represents the target of the rule. This exception is raised when\n    the final term is not callable.\n    \"\"\"\n    def __init__(self) -&gt; None:\n        super().__init__(\"Expected a choice function for the final term in a selector\")\n</code></pre>"},{"location":"modules/#pychoice.selector.SelectorItem","title":"<code>SelectorItem</code>","text":"<p>Abstract base class for items that can be used in choice selectors.</p> <p>SelectorItems define different ways to match against stack frames in choice function call stacks. Each type of SelectorItem implements different matching logic for various callable types.</p> <p>This is an abstract base class - use concrete subclasses like FunctionSelectorItem, ClassSelectorItem, or ChoiceContextSelectorItem.</p> Source code in <code>pychoice/selector.py</code> <pre><code>class SelectorItem:\n    \"\"\"Abstract base class for items that can be used in choice selectors.\n\n    SelectorItems define different ways to match against stack frames in\n    choice function call stacks. Each type of SelectorItem implements\n    different matching logic for various callable types.\n\n    This is an abstract base class - use concrete subclasses like\n    FunctionSelectorItem, ClassSelectorItem, or ChoiceContextSelectorItem.\n    \"\"\"\n    def __init__(self) -&gt; None:\n        pass\n\n    def __str__(self) -&gt; str:\n        raise NotImplementedError\n\n    def __eq__(self, other: object) -&gt; bool:\n        raise NotImplementedError\n\n    def get_callable(self) -&gt; Callable[..., Any] | None:\n        \"\"\"Get the callable object this selector item represents.\n\n        Returns:\n            The callable object, or None if this item doesn't represent a callable\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses\n        \"\"\"\n        raise NotImplementedError\n\n    def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n        \"\"\"Check if this selector item matches a stack frame.\n\n        Args:\n            frame_info: Stack frame to check for matching\n\n        Returns:\n            True if this selector item matches the frame, False otherwise\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"modules/#pychoice.selector.SelectorItem.get_callable","title":"<code>get_callable()</code>","text":"<p>Get the callable object this selector item represents.</p> <p>Returns:</p> Type Description <code>Callable[..., Any] | None</code> <p>The callable object, or None if this item doesn't represent a callable</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>pychoice/selector.py</code> <pre><code>def get_callable(self) -&gt; Callable[..., Any] | None:\n    \"\"\"Get the callable object this selector item represents.\n\n    Returns:\n        The callable object, or None if this item doesn't represent a callable\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/#pychoice.selector.SelectorItem.matches","title":"<code>matches(frame_info)</code>","text":"<p>Check if this selector item matches a stack frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame_info</code> <code>FrameInfo</code> <p>Stack frame to check for matching</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this selector item matches the frame, False otherwise</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Source code in <code>pychoice/selector.py</code> <pre><code>def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n    \"\"\"Check if this selector item matches a stack frame.\n\n    Args:\n        frame_info: Stack frame to check for matching\n\n    Returns:\n        True if this selector item matches the frame, False otherwise\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/#poset-visualization-module","title":"Poset Visualization Module","text":"<p>Poset (Partially Ordered Set) visualization for PyChoice selectors.</p> <p>This module provides tools for analyzing and visualizing the relationships between choice selectors. It builds directed graphs representing the poset structure of selectors, where edges indicate sub-selector relationships, helping developers understand rule precedence and specificity.</p> <p>The poset visualization is particularly useful for debugging complex choice rule hierarchies and understanding how different selectors relate to each other.</p>"},{"location":"modules/#pychoice.poset.build_selector_poset","title":"<code>build_selector_poset(selectors)</code>","text":"<p>Build a directed graph representing the partial order of selectors.</p> <p>Creates a directed acyclic graph (DAG) where nodes represent selectors and edges represent sub-selector relationships. An edge from A to B indicates that A is a sub-selector of B (A is more specific than B).</p> <p>The resulting graph has transitive edges removed for clarity, showing only the direct relationships between selectors in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>selectors</code> <code>list[Selector]</code> <p>List of Selector objects to analyze</p> required <p>Returns:</p> Type Description <code>DiGraph</code> <p>NetworkX DiGraph representing the selector poset with transitive </p> <code>DiGraph</code> <p>reduction applied for visual clarity</p> Example <pre><code>selectors = [\n    Selector([app]),\n    Selector([app, module]),  \n    Selector([app, module, func])\n]\ngraph = build_selector_poset(selectors)\n# Graph shows: [app, module, func] -&gt; [app, module] -&gt; [app]\n</code></pre> Source code in <code>pychoice/poset.py</code> <pre><code>def build_selector_poset(selectors: list[Selector]) -&gt; nx.DiGraph:\n    \"\"\"Build a directed graph representing the partial order of selectors.\n\n    Creates a directed acyclic graph (DAG) where nodes represent selectors\n    and edges represent sub-selector relationships. An edge from A to B\n    indicates that A is a sub-selector of B (A is more specific than B).\n\n    The resulting graph has transitive edges removed for clarity, showing\n    only the direct relationships between selectors in the hierarchy.\n\n    Args:\n        selectors: List of Selector objects to analyze\n\n    Returns:\n        NetworkX DiGraph representing the selector poset with transitive \n        reduction applied for visual clarity\n\n    Example:\n        ```python\n        selectors = [\n            Selector([app]),\n            Selector([app, module]),  \n            Selector([app, module, func])\n        ]\n        graph = build_selector_poset(selectors)\n        # Graph shows: [app, module, func] -&gt; [app, module] -&gt; [app]\n        ```\n    \"\"\"\n    G: nx.DiGraph = nx.DiGraph()\n\n    # Add nodes (each selector becomes a node)\n    for sel in selectors:\n        G.add_node(str(sel))\n\n    # Add edges based on sub-selector relationships\n    for i, a in enumerate(selectors):\n        for j, b in enumerate(selectors):\n            if i == j:\n                continue\n            cmp = a.generic_compare(b)\n            if cmp == 1:\n                # a is a sub-selector of b (more specific than b)\n                G.add_edge(str(a), str(b))\n\n    # Remove transitive edges for clearer visualization\n    # This keeps only direct parent-child relationships\n    G = nx.algorithms.dag.transitive_reduction(G)\n    return G\n</code></pre>"},{"location":"modules/#pychoice.poset.visualize_selector_poset","title":"<code>visualize_selector_poset(selectors, filename=None)</code>","text":"<p>Visualize the poset structure of selectors as a graph diagram.</p> <p>Creates a visual representation of selector relationships using matplotlib and NetworkX. The graph shows the hierarchy of selectors with arrows indicating sub-selector relationships (from more specific to less specific).</p> <p>This visualization helps in understanding: - Which selectors are more specific than others - The overall hierarchy of choice rules - Potential conflicts or overlapping rules - The precedence order that will be used at runtime</p> <p>Parameters:</p> Name Type Description Default <code>selectors</code> <code>list[Selector]</code> <p>List of Selector objects to visualize</p> required <code>filename</code> <code>Optional[str]</code> <p>Optional path to save the visualization. If None, displays interactively</p> <code>None</code> Example <pre><code>from pychoice.poset import visualize_selector_poset\n\n# Create some selectors\nselectors = [\n    Selector([my_app, greet]),\n    Selector([my_app, email_module, greet]),\n    Selector([my_app, email_module, formal_context, greet])\n]\n\n# Visualize and save to file\nvisualize_selector_poset(selectors, \"selector_hierarchy.png\")\n\n# Or display interactively\nvisualize_selector_poset(selectors)\n</code></pre> Note <p>Requires matplotlib and networkx to be installed. The visualization uses a spring layout algorithm to position nodes, so the exact layout may vary between runs but the relationships will be consistent.</p> Source code in <code>pychoice/poset.py</code> <pre><code>def visualize_selector_poset(selectors: list[Selector], filename: Optional[str] = None) -&gt; None:\n    \"\"\"Visualize the poset structure of selectors as a graph diagram.\n\n    Creates a visual representation of selector relationships using matplotlib\n    and NetworkX. The graph shows the hierarchy of selectors with arrows\n    indicating sub-selector relationships (from more specific to less specific).\n\n    This visualization helps in understanding:\n    - Which selectors are more specific than others\n    - The overall hierarchy of choice rules\n    - Potential conflicts or overlapping rules\n    - The precedence order that will be used at runtime\n\n    Args:\n        selectors: List of Selector objects to visualize\n        filename: Optional path to save the visualization. If None, displays interactively\n\n    Example:\n        ```python\n        from pychoice.poset import visualize_selector_poset\n\n        # Create some selectors\n        selectors = [\n            Selector([my_app, greet]),\n            Selector([my_app, email_module, greet]),\n            Selector([my_app, email_module, formal_context, greet])\n        ]\n\n        # Visualize and save to file\n        visualize_selector_poset(selectors, \"selector_hierarchy.png\")\n\n        # Or display interactively\n        visualize_selector_poset(selectors)\n        ```\n\n    Note:\n        Requires matplotlib and networkx to be installed. The visualization\n        uses a spring layout algorithm to position nodes, so the exact\n        layout may vary between runs but the relationships will be consistent.\n    \"\"\"\n    G = build_selector_poset(selectors)\n    pos = nx.spring_layout(G)\n    nx.draw(G, pos, with_labels=True, node_size=1500, node_color=\"lightblue\", arrows=True)\n\n    if filename is not None:\n        plt.savefig(filename)\n    else:\n        plt.show()\n</code></pre>"},{"location":"modules/#tracing-functions","title":"Tracing Functions","text":"<p>PyChoice: A library for managing choices, options, and configurations across abstraction hierarchy.</p> <p>PyChoice provides a systematic way to customize function behavior through rules without  modifying the original functions or breaking abstraction boundaries. It allows for  complex configuration management and code injection patterns.</p> Basic usage <pre><code>import pychoice as choice\n\n@choice.func(args=[\"greeting\"])\ndef greet(name: str, greeting=\"Hello\"):\n    return f\"{greeting} {name}\"\n\nchoice.rule([my_app, greet], greet, greeting=\"Hi\")\n</code></pre>"},{"location":"modules/#pychoice.registry","title":"<code>registry = []</code>  <code>module-attribute</code>","text":"<p>Global registry of all ChoiceFunctions created with @func decorator.</p>"},{"location":"modules/#pychoice.ChoiceContext","title":"<code>ChoiceContext</code>","text":"<p>Base class for choice contexts that provide temporary rule scoping.</p> <p>ChoiceContexts allow you to create temporary scopes where specific choice rules apply. They use Python's context manager protocol and context variables to track when they are active.</p> <p>Attributes:</p> Name Type Description <code>active</code> <p>ContextVar tracking whether this context is currently active</p> Example <pre><code>class DebugContext(ChoiceContext):\n    pass\n\nwith DebugContext():\n    # Rules targeting DebugContext will apply here\n    my_function()  # May use different implementation\n</code></pre> Source code in <code>pychoice/selector.py</code> <pre><code>class ChoiceContext:\n    \"\"\"Base class for choice contexts that provide temporary rule scoping.\n\n    ChoiceContexts allow you to create temporary scopes where specific choice\n    rules apply. They use Python's context manager protocol and context variables\n    to track when they are active.\n\n    Attributes:\n        active: ContextVar tracking whether this context is currently active\n\n    Example:\n        ```python\n        class DebugContext(ChoiceContext):\n            pass\n\n        with DebugContext():\n            # Rules targeting DebugContext will apply here\n            my_function()  # May use different implementation\n        ```\n    \"\"\"\n    active = ContextVar(\"active\", default=False)\n\n    def __enter__(self) -&gt; None:\n        self.active.set(True)\n\n    def __exit__(\n        self, exc_type: BaseException | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -&gt; bool | None:\n        self.active.set(False)\n        return None\n</code></pre>"},{"location":"modules/#pychoice.Match","title":"<code>Match</code>","text":"<p>               Bases: <code>SelectorItem</code></p> <p>Advanced selector item that matches function calls with specific argument values.</p> <p>Match extends basic function matching to also check argument values, allowing for more precise rule targeting based on function parameters.</p> <p>Attributes:</p> Name Type Description <code>item</code> <p>The underlying SelectorItem to match</p> <code>match_kwargs</code> <p>Keyword arguments that must match for this selector to apply</p> Example <pre><code># Match greet() calls where greeting=\"Hi\"\nmatch_item = Match(greet, greeting=\"Hi\")\nselector = Selector([my_app, match_item])\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>class Match(SelectorItem):\n    \"\"\"Advanced selector item that matches function calls with specific argument values.\n\n    Match extends basic function matching to also check argument values, allowing\n    for more precise rule targeting based on function parameters.\n\n    Attributes:\n        item: The underlying SelectorItem to match\n        match_kwargs: Keyword arguments that must match for this selector to apply\n\n    Example:\n        ```python\n        # Match greet() calls where greeting=\"Hi\"\n        match_item = Match(greet, greeting=\"Hi\")\n        selector = Selector([my_app, match_item])\n        ```\n    \"\"\"\n    def __init__(self, func: SEL_I, **kwargs: Any):\n        self.item = new_selector_item(func)\n        self.match_kwargs = kwargs\n\n    def __str__(self) -&gt; str:\n        return str(self.item)\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, Match) and self.item == other.item and self.match_kwargs == other.match_kwargs\n\n    def get_callable(self) -&gt; Callable[..., Any] | None:\n        \"\"\"Get the underlying callable from the wrapped selector item.\"\"\"\n        return self.item.get_callable()\n\n    def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n        \"\"\"Check if this Match selector matches a stack frame.\n\n        First checks if the underlying item matches, then verifies that\n        all specified keyword arguments match the actual call arguments.\n\n        Args:\n            frame_info: Stack frame to check for matching\n\n        Returns:\n            True if both function and arguments match, False otherwise\n        \"\"\"\n        # First check if the underlying item matches\n        if not self.item.matches(frame_info):\n            return False\n\n        # If no kwargs to match, then it's a match\n        if not self.match_kwargs:\n            return True\n\n        # Capture the arguments and compare against expected kwargs\n        captured = self.capture(frame_info)\n\n        # Check if all expected kwargs match the captured values\n        for key, expected_value in self.match_kwargs.items():\n            if key not in captured or captured[key] != expected_value:\n                return False\n\n        return True\n\n    def capture(self, frame_info: inspect.FrameInfo) -&gt; dict[str, Any]:\n        \"\"\"Capture local variables from the matching stack frame.\n\n        Args:\n            frame_info: Stack frame to capture variables from\n\n        Returns:\n            Dictionary of captured local variables\n        \"\"\"\n        return Selector._collect_captures(self.item, frame_info)\n</code></pre>"},{"location":"modules/#pychoice.Match.capture","title":"<code>capture(frame_info)</code>","text":"<p>Capture local variables from the matching stack frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame_info</code> <code>FrameInfo</code> <p>Stack frame to capture variables from</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of captured local variables</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def capture(self, frame_info: inspect.FrameInfo) -&gt; dict[str, Any]:\n    \"\"\"Capture local variables from the matching stack frame.\n\n    Args:\n        frame_info: Stack frame to capture variables from\n\n    Returns:\n        Dictionary of captured local variables\n    \"\"\"\n    return Selector._collect_captures(self.item, frame_info)\n</code></pre>"},{"location":"modules/#pychoice.Match.get_callable","title":"<code>get_callable()</code>","text":"<p>Get the underlying callable from the wrapped selector item.</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def get_callable(self) -&gt; Callable[..., Any] | None:\n    \"\"\"Get the underlying callable from the wrapped selector item.\"\"\"\n    return self.item.get_callable()\n</code></pre>"},{"location":"modules/#pychoice.Match.matches","title":"<code>matches(frame_info)</code>","text":"<p>Check if this Match selector matches a stack frame.</p> <p>First checks if the underlying item matches, then verifies that all specified keyword arguments match the actual call arguments.</p> <p>Parameters:</p> Name Type Description Default <code>frame_info</code> <code>FrameInfo</code> <p>Stack frame to check for matching</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if both function and arguments match, False otherwise</p> Source code in <code>pychoice/funcs.py</code> <pre><code>def matches(self, frame_info: inspect.FrameInfo) -&gt; bool:\n    \"\"\"Check if this Match selector matches a stack frame.\n\n    First checks if the underlying item matches, then verifies that\n    all specified keyword arguments match the actual call arguments.\n\n    Args:\n        frame_info: Stack frame to check for matching\n\n    Returns:\n        True if both function and arguments match, False otherwise\n    \"\"\"\n    # First check if the underlying item matches\n    if not self.item.matches(frame_info):\n        return False\n\n    # If no kwargs to match, then it's a match\n    if not self.match_kwargs:\n        return True\n\n    # Capture the arguments and compare against expected kwargs\n    captured = self.capture(frame_info)\n\n    # Check if all expected kwargs match the captured values\n    for key, expected_value in self.match_kwargs.items():\n        if key not in captured or captured[key] != expected_value:\n            return False\n\n    return True\n</code></pre>"},{"location":"modules/#pychoice.MissingChoiceArg","title":"<code>MissingChoiceArg</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a choice function is missing expected arguments.</p> <p>This occurs when a @choice.func decorator specifies choice arguments that don't exist as parameters in the decorated function.</p> Example <pre><code>@choice.func(args=[\"nonexistent\"])  # This arg doesn't exist\ndef greet(name: str):  # Missing \"nonexistent\" parameter\n    return f\"Hello {name}\"\n# Raises MissingChoiceArg\n</code></pre> Source code in <code>pychoice/args.py</code> <pre><code>class MissingChoiceArg(Exception):\n    \"\"\"Exception raised when a choice function is missing expected arguments.\n\n    This occurs when a @choice.func decorator specifies choice arguments that\n    don't exist as parameters in the decorated function.\n\n    Example:\n        ```python\n        @choice.func(args=[\"nonexistent\"])  # This arg doesn't exist\n        def greet(name: str):  # Missing \"nonexistent\" parameter\n            return f\"Hello {name}\"\n        # Raises MissingChoiceArg\n        ```\n    \"\"\"\n    def __init__(self, func: Callable[..., Any], choice_arg: str):\n        msg = f\"The function {func.__name__} is missing the expected choice kwarg {choice_arg}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"modules/#pychoice.def_rule","title":"<code>def_rule(selector)</code>","text":"<p>Decorator for creating dynamic rules with custom logic.</p> <p>Unlike simple rules created with rule(), def_rule allows you to create rules with custom logic that can dynamically determine parameter values based on captured variables from the call stack.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>SEL</code> <p>List defining the call stack pattern to match</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Decorator function for the rule implementation</p> Example <pre><code>@choice.def_rule([debug_mode, log])\ndef debug_log_rule(captures):\n    # Custom logic based on captured variables\n    return None, {\"level\": \"DEBUG\", \"verbose\": True}\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def def_rule(selector: SEL) -&gt; Any:\n    \"\"\"Decorator for creating dynamic rules with custom logic.\n\n    Unlike simple rules created with rule(), def_rule allows you to create\n    rules with custom logic that can dynamically determine parameter values\n    based on captured variables from the call stack.\n\n    Args:\n        selector: List defining the call stack pattern to match\n\n    Returns:\n        Decorator function for the rule implementation\n\n    Example:\n        ```python\n        @choice.def_rule([debug_mode, log])\n        def debug_log_rule(captures):\n            # Custom logic based on captured variables\n            return None, {\"level\": \"DEBUG\", \"verbose\": True}\n        ```\n    \"\"\"\n    def decorator_args(func: RuleVals) -&gt; RuleVals:\n        # Choose function implementation\n        sel = new_selector(selector)\n        choice_fun = sel.choice_function()\n        if isinstance(choice_fun, ChoiceFunction):\n            choice_fun = cast(ChoiceFunction, choice_fun)\n        else:\n            raise TypeError()\n        choice_fun._add_rule(Rule(sel, None, func, inspect.getdoc(func)))\n        return func\n\n    return decorator_args\n</code></pre>"},{"location":"modules/#pychoice.func","title":"<code>func(args=None)</code>","text":"<p>Decorator to create a choice function from a regular function.</p> <p>This is the primary decorator for creating choice functions. It converts a regular function into a ChoiceFunction that can be customized through rules.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>List of parameter names that can be customized by rules</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., O]], ChoiceFunction[O]]</code> <p>Decorator function that converts a function to a ChoiceFunction</p> Example <pre><code>@choice.func(args=[\"greeting\", \"punctuation\"])\ndef greet(name: str, greeting=\"Hello\", punctuation=\"!\"):\n    return f\"{greeting} {name}{punctuation}\"\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def func[O](args: list[str] | None = None) -&gt; Callable[[Callable[..., O]], ChoiceFunction[O]]:\n    \"\"\"Decorator to create a choice function from a regular function.\n\n    This is the primary decorator for creating choice functions. It converts\n    a regular function into a ChoiceFunction that can be customized through rules.\n\n    Args:\n        args: List of parameter names that can be customized by rules\n\n    Returns:\n        Decorator function that converts a function to a ChoiceFunction\n\n    Example:\n        ```python\n        @choice.func(args=[\"greeting\", \"punctuation\"])\n        def greet(name: str, greeting=\"Hello\", punctuation=\"!\"):\n            return f\"{greeting} {name}{punctuation}\"\n        ```\n    \"\"\"\n    if args is None:\n        args = []\n\n    def decorator_args(func: F) -&gt; ChoiceFunction[O]:\n        func_args = ChoiceFuncImplementation[O](args, func)\n        # Choice interface\n\n        # Add to registry\n        reg = ChoiceFunction[O](func_args)\n        registry.append(reg)\n\n        # Return wrapper\n        return cast(ChoiceFunction[O], functools.wraps(func)(reg))\n\n    return decorator_args\n</code></pre>"},{"location":"modules/#pychoice.impl","title":"<code>impl(implements, args=None)</code>","text":"<p>Decorator to create alternative implementations for choice functions.</p> <p>This decorator creates alternative implementations that can be used by rules to completely replace the behavior of a choice function in specific contexts.</p> <p>Parameters:</p> Name Type Description Default <code>implements</code> <code>ChoiceFunction[O]</code> <p>The ChoiceFunction this will be an implementation for</p> required <code>args</code> <code>list[str] | None</code> <p>List of parameter names this implementation accepts</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., O]], ChoiceFuncImplementation[O]]</code> <p>Decorator function that creates a ChoiceFuncImplementation</p> Example <pre><code>@choice.impl(implements=greet, args=[\"greeting\", \"title\"])\ndef formal_greet(name: str, greeting=\"Dear\", title=\"\"):\n    return f\"{greeting} {title} {name}\"\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def impl[O](\n    implements: ChoiceFunction[O], args: list[str] | None = None\n) -&gt; Callable[[Callable[..., O]], ChoiceFuncImplementation[O]]:\n    \"\"\"Decorator to create alternative implementations for choice functions.\n\n    This decorator creates alternative implementations that can be used by\n    rules to completely replace the behavior of a choice function in specific contexts.\n\n    Args:\n        implements: The ChoiceFunction this will be an implementation for\n        args: List of parameter names this implementation accepts\n\n    Returns:\n        Decorator function that creates a ChoiceFuncImplementation\n\n    Example:\n        ```python\n        @choice.impl(implements=greet, args=[\"greeting\", \"title\"])\n        def formal_greet(name: str, greeting=\"Dear\", title=\"\"):\n            return f\"{greeting} {title} {name}\"\n        ```\n    \"\"\"\n    if args is None:\n        args = []\n\n    def decorator_args(func: F) -&gt; ChoiceFuncImplementation[O]:\n        func_args = ChoiceFuncImplementation[O](args, func)\n        # Choice implementation\n\n        # Add to registry\n        implements._add_func(func, func_args)\n        return cast(ChoiceFuncImplementation[O], functools.wraps(func)(func_args))\n\n    return decorator_args\n</code></pre>"},{"location":"modules/#pychoice.rule","title":"<code>rule(selector, impl, **kwargs)</code>","text":"<p>Create a choice rule that customizes function behavior in specific contexts.</p> <p>Rules define when and how to customize choice functions. They specify a selector (which determines when the rule applies) and either an alternative implementation or parameter overrides.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>SEL</code> <p>List defining the call stack pattern to match</p> required <code>impl</code> <code>ChoiceFunction | ChoiceFuncImplementation | None</code> <p>ChoiceFunction, ChoiceFuncImplementation, or None for parameter-only rules</p> required <code>**kwargs</code> <code>Any</code> <p>Parameter values to apply when this rule matches</p> <code>{}</code> Example <pre><code># Parameter-only rule\nchoice.rule([my_app, greet], greet, greeting=\"Hi\")\n\n# Implementation-switching rule\nchoice.rule([formal_context, greet], formal_greet_impl)\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def rule(selector: SEL, impl: ChoiceFunction | ChoiceFuncImplementation | None, **kwargs: Any) -&gt; None:\n    \"\"\"Create a choice rule that customizes function behavior in specific contexts.\n\n    Rules define when and how to customize choice functions. They specify a selector\n    (which determines when the rule applies) and either an alternative implementation\n    or parameter overrides.\n\n    Args:\n        selector: List defining the call stack pattern to match\n        impl: ChoiceFunction, ChoiceFuncImplementation, or None for parameter-only rules\n        **kwargs: Parameter values to apply when this rule matches\n\n    Example:\n        ```python\n        # Parameter-only rule\n        choice.rule([my_app, greet], greet, greeting=\"Hi\")\n\n        # Implementation-switching rule\n        choice.rule([formal_context, greet], formal_greet_impl)\n        ```\n    \"\"\"\n    if impl is None:\n        # Allow None implementation for args-only rules\n        processed_impl = None\n    elif isinstance(impl, ChoiceFunction):\n        processed_impl = impl.interface\n    elif isinstance(impl, ChoiceFuncImplementation):\n        processed_impl = impl\n    else:\n        raise NonRule()\n    # Choose function implementation\n    sel = new_selector(selector, str(processed_impl) if processed_impl is not None else \"\")\n    choice_fun = sel.choice_function()\n    if isinstance(choice_fun, ChoiceFunction):\n        choice_fun = cast(ChoiceFunction, choice_fun)\n    else:\n        raise TypeError()\n    choice_fun._add_rule(Rule(sel, processed_impl, lambda _: (processed_impl, kwargs)))\n</code></pre>"},{"location":"modules/#pychoice.trace_start","title":"<code>trace_start()</code>","text":"<p>Start tracing choice function calls.</p> <p>Begins recording all choice function invocations and rule applications. Use this to debug and understand which choices are being made in your application.</p> Example <pre><code>choice.trace_start()\nmy_application()  # Run your code\ntrace = choice.trace_stop()\nprint(trace)  # See what choices were made\n</code></pre> Source code in <code>pychoice/__init__.py</code> <pre><code>def trace_start() -&gt; None:\n    \"\"\"Start tracing choice function calls.\n\n    Begins recording all choice function invocations and rule applications.\n    Use this to debug and understand which choices are being made in your application.\n\n    Example:\n        ```python\n        choice.trace_start()\n        my_application()  # Run your code\n        trace = choice.trace_stop()\n        print(trace)  # See what choices were made\n        ```\n    \"\"\"\n    trace_status.start()\n</code></pre>"},{"location":"modules/#pychoice.trace_stop","title":"<code>trace_stop()</code>","text":"<p>Stop tracing and return the collected trace data.</p> <p>Returns:</p> Name Type Description <code>Trace</code> <code>Trace</code> <p>A trace object containing all choice function calls and decisions    made since trace_start() was called.</p> Example <pre><code>choice.trace_start()\nmy_application()\ntrace = choice.trace_stop()\ntrace.save(\"choices.json\")  # Save for analysis\n</code></pre> Source code in <code>pychoice/__init__.py</code> <pre><code>def trace_stop() -&gt; Trace:\n    \"\"\"Stop tracing and return the collected trace data.\n\n    Returns:\n        Trace: A trace object containing all choice function calls and decisions\n               made since trace_start() was called.\n\n    Example:\n        ```python\n        choice.trace_start()\n        my_application()\n        trace = choice.trace_stop()\n        trace.save(\"choices.json\")  # Save for analysis\n        ```\n    \"\"\"\n    return trace_status.stop()\n</code></pre>"},{"location":"modules/#pychoice.wrap","title":"<code>wrap(f, implements, args=None)</code>","text":"<p>Convert an existing function into a choice function implementation.</p> <p>This is a non-decorator alternative to @impl for when you want to convert an existing function into a choice implementation.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[..., O]</code> <p>The function to convert</p> required <code>implements</code> <code>ChoiceFunction[O]</code> <p>The ChoiceFunction this will implement</p> required <code>args</code> <code>list[str] | None</code> <p>List of parameter names this implementation accepts</p> <code>None</code> <p>Returns:</p> Type Description <code>ChoiceFuncImplementation[O]</code> <p>ChoiceFuncImplementation wrapping the provided function</p> Example <pre><code>def existing_greet(name: str, style=\"casual\"):\n    return f\"Hey {name}!\"\n\ncasual_impl = choice.wrap(existing_greet, greet, args=[\"style\"])\n</code></pre> Source code in <code>pychoice/funcs.py</code> <pre><code>def wrap[O](\n    f: Callable[..., O], implements: ChoiceFunction[O], args: list[str] | None = None\n) -&gt; ChoiceFuncImplementation[O]:\n    \"\"\"Convert an existing function into a choice function implementation.\n\n    This is a non-decorator alternative to @impl for when you want to convert\n    an existing function into a choice implementation.\n\n    Args:\n        f: The function to convert\n        implements: The ChoiceFunction this will implement\n        args: List of parameter names this implementation accepts\n\n    Returns:\n        ChoiceFuncImplementation wrapping the provided function\n\n    Example:\n        ```python\n        def existing_greet(name: str, style=\"casual\"):\n            return f\"Hey {name}!\"\n\n        casual_impl = choice.wrap(existing_greet, greet, args=[\"style\"])\n        ```\n    \"\"\"\n    return impl(implements, args=args)(f)\n</code></pre>"},{"location":"rules/","title":"Rules","text":"<p>This guide covers PyChoice's powerful rule system for customizing function behavior. Rules allow you to modify how choice functions behave in different contexts without changing the original function code.</p>"},{"location":"rules/#basic-rules","title":"Basic Rules","text":""},{"location":"rules/#simple-rule-creation","title":"Simple Rule Creation","text":"<p>Use <code>choice.rule()</code> to customize choice function behavior:</p> <pre><code>import pychoice as choice\n\n@choice.func(args=[\"greeting\"])\ndef greet(name: str, greeting=\"Hello\"):\n    return f\"{greeting} {name}\"\n\ndef my_application():\n    return greet(\"World\")\n\n# Create a rule that applies when my_application calls greet\nchoice.rule([my_application, greet], greet, greeting=\"Hi\")\n\nprint(my_application())  # Output: Hi World\n</code></pre> <p>Here, there are several components of a choice rule. The first component is the selector that describes when the rule is applied. The last component of the selector must be a choice function while the first selector components can describe the general situation.</p> <p>The second argument describes what implementation to use for the choice function. Finally, the keyword arguments can be used to override the choice arguments for the implementation.</p>"},{"location":"rules/#specifying-the-choice-implementation","title":"Specifying the Choice Implementation","text":"<p>Rules can specify different implementations to use:</p> <pre><code>@choice.impl(implements=greet)\ndef formal_greet(name: str):\n    return f\"Dear {name}\"\n\ndef business_context():\n    return greet(\"Client\")\n\n# Use the formal implementation in business context\nchoice.rule([business_context, greet], formal_greet)\n\nprint(business_context())  # Output: Dear Client\n</code></pre>"},{"location":"rules/#argument-only-rules","title":"Argument-Only Rules","text":"<p>You can create rules that only modify arguments without changing the implementation:</p> <pre><code>def test_custom_greeting():\n    return greet(\"Alice\")\n\n# Rule that only provides arguments (None implementation)\nchoice.rule([test_custom_greeting, greet], None, greeting=\"Greetings\")\n\nprint(test_custom_greeting())  # Output: Greetings Alice\n</code></pre>"},{"location":"rules/#rule-precedence","title":"Rule Precedence","text":"<p>PyChoice uses rule specificity to determine precedence. More specific rules  take precedence over general ones.</p>"},{"location":"rules/#understanding-precedence","title":"Understanding Precedence","text":"<pre><code>@choice.func(args=[\"greeting\"])\ndef greet(name: str, greeting=\"Hello\"):\n    return f\"{greeting} {name}\"\n\ndef my_application():\n    return email_broadcast()\n\ndef email_broadcast():\n    return write_email()\n\ndef write_email():\n    return greet(\"User\")\n\n# General rule (applies broadly)\nchoice.rule([my_application, greet], greet, greeting=\"Hi\")\n\n# More specific rule (takes precedence)\nchoice.rule([my_application, email_broadcast, greet], greet, greeting=\"Hey\")\n\n# Most specific rule (highest precedence)\nchoice.rule([my_application, email_broadcast, write_email, greet], greet, greeting=\"Hello there\")\n\nprint(my_application())  # Output: Hello there User\n</code></pre>"},{"location":"rules/#advanced-rule-forms","title":"Advanced Rule Forms","text":""},{"location":"rules/#class-based-selectors","title":"Class-Based Selectors","text":"<p>Rules can target specific class methods using tuple syntax:</p> <pre><code>@choice.func()\ndef process_data():\n    return \"default\"\n\n@choice.impl(implements=process_data)\ndef optimized_process():\n    return \"optimized\"\n\nclass DataProcessor:\n    def run_analysis(self):\n        return process_data()\n\nclass FastProcessor(DataProcessor):\n    def run_fast_analysis(self):\n        return process_data()\n\n# Rule for specific class and method\nchoice.rule([(DataProcessor, \"run_analysis\"), process_data], optimized_process)\n\n# Rule for parent class method (affects subclasses too)\nchoice.rule([(DataProcessor, \"run_fast_analysis\"), process_data], optimized_process)\n\n# Usage\nprocessor = DataProcessor()\nfast_processor = FastProcessor()\n\nprint(processor.run_analysis())  # Output: optimized\nprint(fast_processor.run_fast_analysis())  # Output: optimized\n</code></pre>"},{"location":"rules/#context-managers","title":"Context Managers","text":"<p>Create scoped rules using context managers:</p> <pre><code>class DebugContext(choice.ChoiceContext):\n    pass\n\nclass ProductionContext(choice.ChoiceContext):\n    pass\n\n@choice.func(args=[\"level\"])\ndef log(message: str, level=\"INFO\"):\n    return f\"[{level}] {message}\"\n\n# Rules that apply only within specific contexts\nchoice.rule([DebugContext, log], log, level=\"DEBUG\")\nchoice.rule([ProductionContext, log], log, level=\"WARN\")\n\n# Usage\nprint(log(\"Normal message\"))  # Output: [INFO] Normal message\n\nwith DebugContext():\n    print(log(\"Debug message\"))  # Output: [DEBUG] Debug message\n\nwith ProductionContext():\n    print(log(\"Prod message\"))  # Output: [WARN] Prod message\n</code></pre>"},{"location":"rules/#dynamic-rules","title":"Dynamic Rules","text":""},{"location":"rules/#rules-with-capture-logic","title":"Rules with Capture Logic","text":"<p>Use <code>@choice.def_rule</code> to create dynamic rules that can inspect function calls:</p> <pre><code>@choice.func(args=[\"greeting\"])\ndef greet(name: str, greeting=\"Hello\"):\n    return f\"{greeting} {name}\"\n\ndef wrap_greet(name: str):\n    return greet(name)\n\ndef test_dynamic():\n    return wrap_greet(\"Dynamic\")\n\n@choice.def_rule([test_dynamic, wrap_greet, greet])\ndef dynamic_rule(captures):\n    \"\"\"\n    The docstring here is used to document the underlying reasons behind the rule\n    captures[0]: Arguments to test_dynamic\n    captures[1]: Arguments to wrap_greet  \n    captures[2]: Arguments to greet\n    \"\"\"\n    # Access the name parameter from wrap_greet call\n    name = captures[1]['name']\n    return greet, {\"greeting\": f\"Dynamic {name}\"}\n\nprint(test_dynamic())  # Output: Dynamic Dynamic Dynamic\n</code></pre>"},{"location":"rules/#conditional-rules","title":"Conditional Rules","text":"<p>Rules can return <code>None</code> to skip application:</p> <pre><code>@choice.def_rule([greet])\ndef conditional_rule(captures):\n    \"\"\"Only apply rule for specific names\"\"\"\n    if \"name\" in captures[0] and captures[0][\"name\"] == \"special\":\n        return greet, {\"greeting\": \"Very Special\"}\n    return None  # Don't apply rule for other names\n\nprint(greet(\"normal\"))   # Output: Hello normal\nprint(greet(\"special\"))  # Output: Very Special special\n</code></pre>"},{"location":"rules/#argument-matching","title":"Argument Matching","text":""},{"location":"rules/#pattern-matching-rules","title":"Pattern Matching Rules","text":"<p>Use <code>choice.Match</code> to create rules based on function arguments:</p> <pre><code># Rule that applies only when greet is called with name=\"VIP\"\nchoice.rule([choice.Match(greet, name=\"VIP\")], greet, greeting=\"Welcome\")\n\nprint(greet(\"User\"))  # Output: Hello User\nprint(greet(\"VIP\"))   # Output: Welcome VIP\n</code></pre>"},{"location":"rules/#complex-matching-logic","title":"Complex Matching Logic","text":"<p>Combine matching with dynamic rules:</p> <pre><code>@choice.def_rule([greet])\ndef smart_greeting_rule(captures):\n    \"\"\"Apply different greetings based on name patterns\"\"\"\n    if \"name\" not in captures[0]:\n        return None\n\n    name = captures[0][\"name\"]\n\n    if name.startswith(\"Dr.\"):\n        return greet, {\"greeting\": \"Good day\"}\n    elif name.startswith(\"Prof.\"):\n        return greet, {\"greeting\": \"Greetings\"}\n    elif name.isupper():\n        return greet, {\"greeting\": \"Hey\"}\n\n    return None\n\nprint(greet(\"Dr. Smith\"))    # Output: Good day Dr. Smith\nprint(greet(\"Prof. Jones\"))  # Output: Greetings Prof. Jones  \nprint(greet(\"ROBOT\"))        # Output: Hey ROBOT\nprint(greet(\"Alice\"))        # Output: Hello Alice\n</code></pre>"}]}